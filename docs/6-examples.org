* Examples

** Traffic light system example

*** Problem Description

In this example, we will model a simple traffic light system using the xDEVS/Python API. The traffic light will cycle through three states: Green, Yellow, and Red. Each state will have a specific duration, and the system will transition between these states in a loop. We will create an atomic model for the traffic light, which will handle the state transitions and timing. The traffic light will have one output port to indicate the current state.

*** Traffic Light Model

#+begin_src python
from xdevs.models import Atomic, Port
from xdevs.sim import Coordinator, SimulationClock

# Define the states
STATE_GREEN = "Green"
STATE_YELLOW = "Yellow"
STATE_RED = "Red"

class TrafficLight(Atomic):
    def __init__(self, name: str, green_time: float, yellow_time: float, red_time: float):
        super().__init__(name)
        self.green_time = green_time
        self.yellow_time = yellow_time
        self.red_time = red_time

        self.state = STATE_GREEN
        self.sigma = green_time

        self.output_port = Port(str, "state")
        self.add_out_port(self.output_port)

    def initialize(self):
        self.hold_in(STATE_GREEN, self.green_time)

    def deltint(self):
        if self.state == STATE_GREEN:
            self.state = STATE_YELLOW
            self.hold_in(STATE_YELLOW, self.yellow_time)
        elif self.state == STATE_YELLOW:
            self.state = STATE_RED
            self.hold_in(STATE_RED, self.red_time)
        elif self.state == STATE_RED:
            self.state = STATE_GREEN
            self.hold_in(STATE_GREEN, self.green_time)

    def deltext(self, e):
        pass

    def lambdaf(self):
        self.output_port.add(self.state)

    def exit(self):
        pass

# Simulation setup
if __name__ == "__main__":
    green_time = 10.0
    yellow_time = 2.0
    red_time = 8.0

    traffic_light = TrafficLight("TrafficLight", green_time, yellow_time, red_time)
    clock = SimulationClock()
    coordinator = Coordinator(traffic_light, clock)

    coordinator.initialize()
    coordinator.simulate(50)  # Simulate for 50 iterations
#+end_src

*** Explanation

1. *TrafficLight Class*: This class extends the =Atomic= class from the xDEVS library. It defines the traffic light states and their durations.
   - =initialize()=: Sets the initial state to Green and the initial time advance (=sigma=) to the green light duration.
   - =deltint()=: Handles internal transitions between states.
   - =lambdaf()=: Outputs the current state to the =output_port=.
   - =exit()=: Placeholder for any cleanup operations.

2. *Simulation Setup*: The main block sets up the traffic light model with specified durations for each state. It then creates a =Coordinator= to manage the simulation and runs the simulation for 50 iterations.

This example demonstrates how to model a simple traffic light system using the xDEVS/Python API, showcasing the basic principles of discrete event simulation with DEVS formalism.

*** Exercise

Modify the previous example. There should be an output right after the change in the state, i.e., once the light turns green, yellow, or red, the output is triggered with the new color, instantaneously.

** Queueing system simulation

*** Problem Description

In this example, we will simulate a queueing system, such as a bank or a customer service center, using the xDEVS/Python API. The system will consist of a generator that produces customers, a queue where customers wait, and a server that processes the customers.

The goal is to model the arrival, waiting, and service processes. We will create atomic models for the generator, queue, and server. The generator will produce customers at a specified rate. The queue will manage the waiting customers. Unlike a simple "push" system, the Server will actively "pull" customers from the Queue by sending a request message when it becomes idle. This ensures the server only receives a customer when it is ready, preventing customer loss.

*** Queueing System Model

#+begin_src python :tangle src/queueing-example.py
import logging
import xdevs
from xdevs.models import Atomic, Port, Coupled
from xdevs.sim import Coordinator, SimulationClock

logger = xdevs.get_logger(__name__, logging.INFO)

class Customer:
    def __init__(self, id):
        self.id = id

class Generator(Atomic):
    def __init__(self, name, interarrival_time):
        super().__init__(name)
        self.interarrival_time = interarrival_time
        self.output_port = Port(Customer, "out")
        self.add_out_port(self.output_port)

    def initialize(self):
        self.customer_id = 1
        self.hold_in("active", self.interarrival_time)

    def deltint(self):
        self.customer_id += 1
        self.hold_in("active", self.interarrival_time)

    def lambdaf(self):
        logger.info(f"Generator::Arriving customer {self.customer_id} to queue.")
        self.output_port.add(Customer(self.customer_id))

    def deltext(self, e):
        pass

    def exit(self):
        pass

class Queue(Atomic):
    def __init__(self, name):
        super().__init__(name)
        self.input_request = Port(bool, "request")
        self.input_customer = Port(Customer, "in")
        self.output_customer = Port(Customer, "out")
        self.add_in_port(self.input_request)
        self.add_in_port(self.input_customer)
        self.add_out_port(self.output_customer)

    def initialize(self):
        self.queue = []
        self.customer_requested = False
        self.next_customer = None
        self.passivate()

    def deltint(self):
        self.customer_requested = False
        self.next_customer = None
        self.passivate()

    def deltext(self, e):
        self.continuef(e)            
        if self.input_customer:
            self.queue.append(self.input_customer.get())
            logger.info(f"Queue::Customer {self.queue[-1].id} in queue. Queue size: {len(self.queue)}")
            self.passivate()
        if self.input_request:
            self.customer_requested = True
            self.passivate()
        if self.customer_requested and not self.next_customer and self.queue:
            self.next_customer = self.queue.pop(0)
            self.hold_in("active", 0.1) # Small delay to simulate moving customer

    def lambdaf(self):
        logger.info(f"Queue::Customer {self.next_customer.id} from queue to server. Queue size: {len(self.queue)}")
        self.output_customer.add(self.next_customer)

    def exit(self):
        pass

class Server(Atomic):
    def __init__(self, name, service_time):
        super().__init__(name)
        self.service_time = service_time
        self.input_customer = Port(Customer, "in")
        self.output_request = Port(bool, "request")
        self.add_in_port(self.input_customer)
        self.add_out_port(self.output_request)

    def initialize(self):
        self.current_customer = None
        self.hold_in("request", 0.1)

    def deltint(self):
        if self.current_customer:
            logger.info(f"Server::Finished attending customer {self.current_customer.id}.")
            self.current_customer = None
            self.hold_in("request", 0.1)
        else:
            self.passivate()

    def deltext(self, e):
        self.continuef(e)
        if self.input_customer:
            if self.current_customer:
                logger.error(f"Server::ERROR: Server is already attending customer {self.current_customer.id}")
            else:
                self.current_customer = self.input_customer.get()
                logger.info(f"Server::Attending customer {self.current_customer.id}.")
                self.hold_in("busy", self.service_time)

    def lambdaf(self):
        if self.current_customer is None:
            logger.info(f"Server::Requesting customer.")
            self.output_request.add(True)

    def exit(self):
        pass

class QueueingSystem(Coupled):
    def __init__(self, name, interarrival_time, service_time):
        super().__init__(name)
        self.generator = Generator("Generator", interarrival_time)
        self.queue = Queue("Queue")
        self.server = Server("Server", service_time)

        self.add_component(self.generator)
        self.add_component(self.queue)
        self.add_component(self.server)

        self.add_coupling(self.generator.output_port, self.queue.input_customer)
        self.add_coupling(self.queue.output_customer, self.server.input_customer)
        self.add_coupling(self.server.output_request, self.queue.input_request)
#+end_src

*** Simulation setup

#+begin_src python :tangle src/queueing-example.py
if __name__ == "__main__":
    interarrival_time = 2.0
    service_time = 5.0

    queueing_system = QueueingSystem("QueueingSystem", interarrival_time, service_time)
    clock = SimulationClock()
    coordinator = Coordinator(queueing_system, clock)

    coordinator.initialize()
    coordinator.simulate_time(50)  # Simulate for 50 time units
#+end_src

*** Results

Running the simulation script (with =interarrival_time = 2.0= and =service_time = 5.0=) will produce a log output similar to the one below. This log demonstrates the "pull" mechanism:

#+begin_src bash
(.venv) xdevs@laptop:~/git/xdevs/docs/src$ python3 queueing-example.py 
Server::Requesting customer.
Generator::Arriving customer 1 to queue.
Queue::Customer 1 in queue. Queue size: 1
Queue::Customer 1 from queue to server. Queue size: 0
Server::Attending customer 1.
Generator::Arriving customer 2 to queue.
Queue::Customer 2 in queue. Queue size: 1
Generator::Arriving customer 3 to queue.
Queue::Customer 3 in queue. Queue size: 2
Server::Finished attending customer 1.
Server::Requesting customer.
Queue::Customer 2 from queue to server. Queue size: 1
Server::Attending customer 2.
Generator::Arriving customer 4 to queue.
Queue::Customer 4 in queue. Queue size: 2
Generator::Arriving customer 5 to queue.
Queue::Customer 5 in queue. Queue size: 3
Generator::Arriving customer 6 to queue.
Queue::Customer 6 in queue. Queue size: 4
...
#+end_src

*** Explanation

This Python script models a classic **G/G/1 queueing system** using the =xdevs= library for Discrete Event System Specification (DEVS). The system consists of three main components (Atomic models) combined into one Coupled model.

**** Components

- *=Generator=*:: This model creates new =Customer= objects. It schedules an internal event to generate a new customer every =interarrival_time=. In this simulation, this time is fixed at *2.0 time units*.
- *=Queue=*:: This model acts as a buffer. It uses a "pull-based" mechanism.
  - It receives customers from the =Generator= and adds them to an internal list (=self.queue=).
  - It *also* receives requests from the =Server= on its =input_request= port.
  - Only when it has *both* a pending request from the server (=self.customer_requested= is True) *and* at least one customer in its queue, it schedules an event to send the next customer. A small delay of 0.1 time units is used to simulate moving the customer.
- *=Server=*:: This model processes customers.
  - When it is idle, it sends a request (=True=) on its =output_request= port to the =Queue=.
  - When it receives a customer from the =Queue=, it enters a "busy" state and holds for the =service_time=. In this simulation, this time is fixed at *5.0 time units*.
  - After the service is complete, it logs the completion and immediately schedules another event to request a new customer.

**** System and Simulation

- *=QueueingSystem=*:: This is the main =Coupled= model that connects the three components:
  - =Generator.output_port= -> =Queue.input_customer=
  - =Queue.output_customer= -> =Server.input_customer=
  - =Server.output_request= -> =Queue.input_request=
- *=Simulation Run=*:: The main script initializes this =QueueingSystem= with the specified interarrival time (2.0) and service time (5.0). It then runs a simulation for a total of *50.0 time units*. The logging (e.g., "Arriving customer...", "Attending customer...") provides a trace of the discrete events as they occur during this 50-unit simulation.

** Parallel Simulation Example

In this section, we will demonstrate how to run a parallel simulation using the DEVS/Java API. We will use the Experimental Frame - Processor (EFP) model as an example. The EFP model consists of a generator, a processor, and a transducer. The generator produces jobs, the processor processes them, and the transducer collects statistics.

*** EFP Model

The EFP model is a coupled model that integrates the generator, processor, and transducer components.

#+begin_src java
package xdevs.core.examples.efp;

import java.util.logging.Level;
import xdevs.core.modeling.Coupled;
import xdevs.core.simulation.Coordinator;
import xdevs.core.util.DevsLogger;

public class Efp extends Coupled {

    public Efp(String name, double generatorPeriod, double processorPeriod, double transducerPeriod) {
        super(name);

        Ef ef = new Ef("ef", generatorPeriod, transducerPeriod);
        super.addComponent(ef);
        Processor processor = new Processor("processor", processorPeriod);
        super.addComponent(processor);

        super.addCoupling(ef.oOut, processor.iIn);
        super.addCoupling(processor.oOut, ef.iIn);
    }

    public static void main(String args[]) {
        DevsLogger.setup(Level.FINE);
        Efp efp = new Efp("efp", 1, 3, 100);
        Coordinator coordinator = new Coordinator(efp);
        coordinator.initialize();
        coordinator.simulate(Long.MAX_VALUE);
        coordinator.exit();
    }
}
#+end_src

*** Generator

The generator produces jobs at a specified period.

#+begin_src java
package xdevs.core.examples.efp;

import org.w3c.dom.Element;
import xdevs.core.modeling.Atomic;
import xdevs.core.modeling.Port;

public class Generator extends Atomic {
    public Port<Job> iStop = new Port<>("iStop");
    public Port<Job> oOut = new Port<>("oOut");
    protected int jobCounter;
    protected double period;

    public Generator(String name, double period) {
        super(name);
        super.addInPort(iStop);
        super.addOutPort(oOut);
        this.period = period;
    }

    public Generator(Element xmlAtomic) {
        this(xmlAtomic.getAttribute("name"), Double.parseDouble(
                ((Element) (xmlAtomic.getElementsByTagName("constructor-arg").item(0))).getAttribute("value")));
    }

    @Override
    public void initialize() {
        jobCounter = 1;
        this.holdIn("active", period);
    }

    @Override
    public void exit() {
    }

    @Override
    public void deltint() {
        jobCounter++;
        this.holdIn("active", period);
    }

    @Override
    public void deltext(double e) {
        super.resume(e);
        super.passivate();
    }

    @Override
    public void lambda() {
        Job job = new Job("" + jobCounter + "");
        oOut.addValue(job);
    }
}
#+end_src

*** Processor

The processor processes jobs with a given processing time.

#+begin_src java
package xdevs.core.examples.efp;

import org.w3c.dom.Element;
import xdevs.core.modeling.Atomic;
import xdevs.core.modeling.Port;

public class Processor extends Atomic {

    protected Port<Job> iIn = new Port<>("in");
    protected Port<Job> oOut = new Port<>("out");
    protected Job currentJob = null;
    protected double processingTime;
    protected double clock;

    public Processor(String name, double processingTime) {
        super(name);
        super.addInPort(iIn);
        super.addOutPort(oOut);
        this.processingTime = processingTime;
        this.clock = 0;
    }

    public Processor(Element xmlAtomic) {
        this(xmlAtomic.getAttribute("name"), 
             Double.parseDouble(((Element)(xmlAtomic.getElementsByTagName("constructor-arg").item(0))).getAttribute("value")));
    }

    @Override
    public void initialize() {
        super.passivate();
    }

    @Override
    public void exit() {
    }

    @Override
    public void deltint() {
        clock += super.getSigma();
        super.passivate();
    }

    @Override
    public void deltext(double e) {
        super.resume(e);
        clock += e;
        if (super.phaseIs("passive")) {
            currentJob = iIn.getSingleValue();
            super.holdIn("active", processingTime);
            currentJob.time = clock;
        }
    }

    @Override
    public void lambda() {
        oOut.addValue(currentJob);
    }
}
#+end_src

*** Transducer

The transducer collects statistics about the jobs and finishes the simulation when the observation time is reached.

#+begin_src java
package xdevs.core.examples.efp;

import java.util.LinkedList;
import java.util.logging.Logger;
import org.w3c.dom.Element;
import xdevs.core.modeling.Atomic;
import xdevs.core.modeling.Port;

public class Transducer extends Atomic {

    private static final Logger LOGGER = Logger.getLogger(Transducer.class.getName());

    public Port<Job> iArrived = new Port<>("iArrived");
    public Port<Job> iSolved = new Port<>("iSolved");
    public Port<Job> oOut = new Port<>("oOut");
    protected LinkedList<Job> jobsArrived = new LinkedList<>();
    protected LinkedList<Job> jobsSolved = new LinkedList<>();
    protected double observationTime;
    protected double totalTa;
    protected double clock;

    public Transducer(String name, double observationTime) {
        super(name);
        super.addInPort(iArrived);
        super.addInPort(iSolved);
        super.addOutPort(oOut);
        totalTa = 0;
        clock = 0;
        this.observationTime = observationTime;
    }

    public Transducer(Element xmlAtomic) {
        this(xmlAtomic.getAttribute("name"), 
             Double.parseDouble(((Element)(xmlAtomic.getElementsByTagName("constructor-arg").item(0))).getAttribute("value")));
    }

    @Override
    public void initialize() {
        super.holdIn("active", observationTime);
    }

    @Override
    public void exit() {
    }

    @Override
    public void deltint() {
        clock = clock + getSigma();
        double throughput;
        double avgTaTime;
        if (phaseIs("active")) {
            if (!jobsSolved.isEmpty()) {
                avgTaTime = totalTa / jobsSolved.size();
                if (clock > 0.0) {
                    throughput = jobsSolved.size() / clock;
                } else {
                    throughput = 0.0;
                }
            } else {
                avgTaTime = 0.0;
                throughput = 0.0;
            }
            LOGGER.info("End time: " + clock);
            LOGGER.info("Jobs arrived : " + jobsArrived.size());
            LOGGER.info("Jobs solved : " + jobsSolved.size());
            LOGGER.info("Average TA = " + avgTaTime);
            LOGGER.info("Throughput = " + throughput);
            holdIn("done", 0);
        } else {
            passivate();
        }
    }

    @Override
    public void deltext(double e) {
        super.resume(e);
        clock = clock + e;
        if (phaseIs("active")) {
            if (!iArrived.isEmpty()) {
                Job job = iArrived.getSingleValue();
                LOGGER.fine("Start job " + job.id + " @ t = " + clock);
                job.time = clock;
                jobsArrived.add(job);
            }
            if (!iSolved.isEmpty()) {
                for(Job job : iSolved.getValues()) {
                    totalTa += (clock - job.time);
                    LOGGER.fine("Finish job " + job.id + " @ t = " + clock);
                    job.time = clock;
                    jobsSolved.add(job);
                }
            }
        }
    }

    @Override
    public void lambda() {
        if (phaseIs("done")) {
            Job job = new Job("null");
            oOut.addValue(job);
        }
    }
}
#+end_src

*** Parallel Execution

The parallel coordinator manages the parallel execution of the simulation.

#+begin_src java
// Complete the imports ...

public class ParallelExample {

    // ...

    public static void main(String[] args) {
        DevsLogger.setup(Level.INFO);
        Efp efp = new Efp("EFP", 1, 3, 1000000);
        CoordinatorParallel coordinator = new CoordinatorParallel(efp);
        coordinator.initialize();
        coordinator.simulate(Long.MAX_VALUE);
        coordinator.exit();
    }
}
#+end_src

This example demonstrates how to run a parallel simulation using the DEVS/Java API. The =CoordinatorParallel= class manages the parallel execution of the simulation, allowing for efficient processing of the EFP model components.
