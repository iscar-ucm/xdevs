<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-05-31 vie 12:09 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>xDEVS user's manual</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="José L. Risco-Martín" />
<meta name="keywords" content="devs, simulation, xdevs, discrete event system" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">xDEVS user's manual</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org65750af">Introduction to xDEVS</a>
<ul>
<li><a href="#org99bfaa8">Introduction</a></li>
<li><a href="#orged8bdec">Top features</a></li>
<li><a href="#orge9a54e7">Quick start</a></li>
</ul>
</li>
<li><a href="#orgff138aa">The DEVS formalism</a>
<ul>
<li><a href="#orgd9be9a9">Bibliography</a></li>
</ul>
</li>
<li><a href="#orge7652da">Getting started with xDEVS</a>
<ul>
<li><a href="#orgceb1795">Output Function</a></li>
<li><a href="#org7f02af6">Internal Transition Function</a></li>
<li><a href="#org1197072">External Transition Function</a></li>
<li><a href="#org8a08d8a">Complete model implementation</a></li>
<li><a href="#org1465cbd">Running the model</a></li>
</ul>
</li>
<li><a href="#org7c55f93">Building models in xDEVS</a>
<ul>
<li><a href="#org6ced4fb">Atomic models</a></li>
<li><a href="#org7d650f4">Coupled models</a></li>
<li><a href="#orgb612d79">Models configuration</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org65750af" class="outline-2">
<h2 id="org65750af">Introduction to xDEVS</h2>
<div class="outline-text-2" id="text-org65750af">
</div>
<div id="outline-container-org99bfaa8" class="outline-3">
<h3 id="org99bfaa8">Introduction</h3>
<div class="outline-text-3" id="text-org99bfaa8">
<p>
xDEVS stands for <i>A cross-platform (x) Discrete EVent System simulator</i>. This library includes a set of C, C++, C#, Go, Java, Python and Rust repositories that provide an event-driven simulation interface. This interface follows the formalism <i>Discrete Event System Specification (DEVS)</i>. The project final goal is to elaborate the fastest DEVS simulation interface with capacity to simulate models in virtual and real time, and to run simulations in sequential (single-threaded), parallel (multi-threaded) and distributed (not shared memory) architectures. 
</p>

<p>
Research in the xDEVS interface can be found in <a href="https://doi.org/10.1002/spe.3168">xDEVS: A toolkit for interoperable modeling and simulation of formal discrete event systems</a>. Please, cite our article in case you find xDEVS useful. This way we can gain visibility:
</p>

<ul class="org-ul">
<li>Risco-Martín, JL, Mittal, S, Henares, K, Cardenas, R, Arroba, P. xDEVS: A toolkit for interoperable modeling and simulation of formal discrete event systems. Softw Pract Exper. 2022; 1- 42. <a href="10.1002/spe.3168">10.1002/spe.3168</a></li>
</ul>

<p>
There are seven repositories associated with xDEVS, each one offering the equivalent simulation interface for each corresponding programming language.
</p>

<ul class="org-ul">
<li>xDEVS/C (<a href="https://github.com/iscar-ucm/xdevs.c">xdevs.c</a>)</li>
<li>xDEVS/C++ (<a href="https://github.com/iscar-ucm/xdevs.cpp">xdevs.cpp</a>)</li>
<li>xDEVS/C# (<a href="https://github.com/iscar-ucm/xdevs.cs">xdevs.cs</a>)</li>
<li>xDEVS/Go (<a href="https://github.com/iscar-ucm/xdevs.go">xdevs.go</a>)</li>
<li>xDEVS/Java (<a href="https://github.com/iscar-ucm/xdevs.java">xdevs.java</a>) - <a href="https://iscar-ucm.github.io/xdevs.java">API documentation</a></li>
<li>xDEVS/Python (<a href="https://github.com/iscar-ucm/xdevs.py">xdevs.py</a>)</li>
<li>xDEVS/Rust (<a href="https://github.com/iscar-ucm/xdevs.rs">xdevs.rs</a>)</li>
<li>xDEVS/Rust for embedded systems (<a href="https://github.com/iscar-ucm/xdevs_no_std.rs">xdevs<sub>no</sub><sub>std.rs</sub></a>)</li>
</ul>

<p>
All the repositories are included as submodules inside this main repository.
</p>

<p>
The xDEVS user's manual can be found <a href="https://iscar-ucm.github.io/xdevs/">here</a>.
</p>
</div>
</div>

<div id="outline-container-orged8bdec" class="outline-3">
<h3 id="orged8bdec">Top features</h3>
<div class="outline-text-3" id="text-orged8bdec">
<ul class="org-ul">
<li>PDEVS Modeling and Simulation formalism</li>
<li>Object-Oriented Programming</li>
<li>Support for sequential, parallel and distributed (this last feature only in Java and Python, for now) architectures.</li>
<li>Good performance, compared to other simulation engines</li>
</ul>
</div>
</div>

<div id="outline-container-orge9a54e7" class="outline-3">
<h3 id="orge9a54e7">Quick start</h3>
<div class="outline-text-3" id="text-orge9a54e7">
<p>
Switch to the corresponding particular language. A README file will be found to start with minimal examples and demos.
</p>
</div>
</div>
</div>

<div id="outline-container-orgff138aa" class="outline-2">
<h2 id="orgff138aa">The DEVS formalism</h2>
<div class="outline-text-2" id="text-orgff138aa">
<p>
The Discrete EVent system Specification (DEVS) formalism [1] was first introduced by Zeigler in 1976, to provide a rigorous common basis for discrete-event modeling and simulation. A "common" basis means that it is possible to express popular discrete-event formalisms such as event-scheduling, activity-scanning and process-interaction using the DEVS formalism.
</p>

<p>
The class of formalisms denoted as discrete-event is characterized by a continuous time base where only a finite number of events can occur during a finite time-span. This contrasts with Discrete Time System Specification (DTSS) formalisms where the time base is isomorphic to N, and with Differential Equation System Specification (DESS, or continuous-time) formalisms in which the state of the system may change continuously over time.
</p>

<p>
The Formalism Transformation Graph (FTG) published by H. Vangheluwe in [3] and shown in Figure 1, depicts behavior-conserving transformations between some important formalisms. The graph distinguishes between continuous-time formalisms on the left-hand side, and discrete formalisms (both discrete-time and discrete-event) on the right-hand side. Although the graph suggests that formalisms can be mapped onto a common formalism on their respective sides, very few transformations allow crossing the middle-line: this illustrates why hybrid systems (those that bring together both discrete and continuous systems) are difficult to solve.
</p>

<p>
<img src="./fig/ftg.png" alt="ftg.png" />
Figure 1. Formalism transformation graph (FTG) [3].
</p>

<p>
The traditional approach to solve continuous-time problems is based on discretization, which approximates a continuous-time model by a discrete-time system (difference equations). A partitioning of the time-axis, as is the case in discretization, is however hard to harmonize with a partitioning of the state space, as is performed in discrete-event systems. In this regard, mapping continuous-time formalisms (ODEs and semi-explicit DAEs) onto the DEVS formalism (this corresponds to the arrow going from "scheduling-hybrid-DAE" to "DEVS" on the FTG) may be performed through quantization. 
</p>

<p>
The closure property (under composition or coupling) of systems such as DEVS offers the possibility to describe a model as a hierarchical composition of simpler sub-components. Apart from the obvious advantages associated with modularity (conceptual level, component reusability), a significant gain in the efficiency of simulating large, complex dynamic systems can also be achieved by using multi-rate integration (employing different integration frame rates for the simulation of fast and slow sub-components), either on a single or on multiple processors (parallelization).
</p>

<p>
Although some continuous-time formalisms (e.g., causal-block diagram simulation tools) allow model hierarchization, multi-rate integration mixes poorly with traditional approaches where discretization along the time-axis forces the simulator to work explicitly with the global time base. This, in contrast to discrete-event formalisms where the simulator is concerned with local state space changes, and the time base is dealt with implicitly. Discrete event concepts are thus better suited for parallel distributed simulation, and much effort has been devoted to the development of conservative (e.g., Chandy-Misra approach), optimistic (e.g., Time-Warp) and real-time (e.g., DARPA's Distributed Interactive Simulation) parallel discrete event simulation techniques. The relevance of DEVS in that context is illustrated by the concept of the DEVS bus which concerns the use of DEVS models as "wrappers" to enable a variety of models to inter operate in a networked simulation. The DEVS bus has been implemented on top of the DoD's High Level Architecture (HLA) standard, itself based on the Run-Time Infrastructure (RTI) protocol.
</p>

<p>
According to DEVS theory, the system of interest is seen as a model and the corresponding simulator. The model represents a simplified version of reality and its structure. The model is built considering the conditions of experimentation of the system of interest, including the work conditions of the real system and its application domain. Thus, the model is restricted to the experimental framework under which it was developed.
</p>

<p>
This model is subsequently used to build a simulator. The simulator is able to change the state of the model by running all the necessary state transitions already defined in the model. All the transitions are executed in an appropriate order, according to the model definition.
</p>

<p>
DEVS was created for modeling and simulation of discrete-event dynamic systems. As a result, it defines a formal way to define systems whose states change either upon the reception of an input event or due to the expiration of a time delay. In order to deal with the system under study, the model can be organized hierarchically in such a way that higher-level components in a system are decomposed into simpler elements. 
</p>

<p>
The formal separation between model and simulator and the hierarchical and modular nature of the DEVS formalism have enabled carrying out of formal proofs on the different entities under study. One of them is the proof of composability of the subcomponents (including legitimacy and equivalence between multicomponent models). The second is the ability to conduct proofs of correctness of the simulation algorithms, which result in simulators rigorously verified. All the proofs are based on formal transformations between each of the representations, trying to prove the equivalence between the entities under study at different levels of abstraction. For instance, we can prove that the mathematical entity simulator is able to execute correctly the behavior described by the mathematical entity model, which represents the system.
Different mathematical mechanisms are used to prove these points, including the mathematical manipulation of the abstraction hierarchy, observation of I/O trajectories (to ensure that different levels of specification correctly describe the system’ structure) and decomposition concepts (DEVS is closed under composition, which means that a composite model integrated by multiple components is equivalent to an atomic component).
</p>

<p>
The reader should refer to the book Theory of Modeling and Simulation [1], to understand the details behind the mathematical background of these techniques. 
</p>
</div>

<div id="outline-container-orga89397d" class="outline-4">
<h4 id="orga89397d">The parallel DEVS formalism</h4>
<div class="outline-text-4" id="text-orga89397d">
<p>
The parallel DEVS approach was introduced, after 15 years, as a revision of Classic DEVS. Currently, parallel DEVS is the prevalent DEVS, implemented in many libraries. In the following, unless it is explicitly noted, the use of DEVS implies parallel DEVS.
</p>

<p>
DEVS enables the representation of a system by three sets and five functions: input set (X), output set (Y), state set (S), external transition function (&delta;<sub>ext</sub>), internal transition function (&delta;<sub>int</sub>), confluent function (&delta;<sub>con</sub>), output function (&lambda;), and time advance function (ta). 
</p>

<p>
DEVS models are of two types: atomic and coupled. Atomic DEVS processes input events based on their model's current state and condition, generates output events and transition to the next state. The coupled model is the aggregation/composition of two or more atomic and coupled models connected by explicit couplings. Particularly, an atomic model is defined by the following equation:
</p>

<p>
A=&lt; <b>X</b>, <b>Y</b>, <b>S</b>, &delta;<sub>ext</sub>,  &delta;<sub>int</sub>, &delta;<sub>con</sub>, &lambda;, ta &gt;
</p>

<p>
where:
</p>

<ul class="org-ul">
<li><b>X</b> is the input set, usually defined as the set of pairs port-value (see DEVS with ports in [1]).</li>
<li><b>Y</b> is the output set, usually defined as the set of pairs port-value (see DEVS with ports in [1])..</li>
<li><b>S</b> is the state set.</li>
<li>&delta;<sub>ext</sub> : <b>Q</b> &times; <b>X<sup>b</sup></b> &rarr; <b>S</b> is the external transition function, Q={(s,e):s &isin; S, e &isin; [0,ta(s)]} is total state set and e is the elapsed time since the last transition, whereas X<sup>b</sup> is the set of bags over elements in X. This function is automatically executed when an external event arrives, changing the current state if needed.</li>
<li>&delta;<sub>int</sub> : S &rarr; S is the internal transition function. This function is executed right after the output (&lambda;) function and is used to change the state S.</li>
<li>&delta;<sub>con</sub>: Q &times; X<sup>b</sup> &rarr; S is the confluent function. This transition decides the next state in cases of collision between external and internal events, i.e., an external event is received and elapsed time equals time-advance. Typically, &delta;<sub>con</sub>(s,ta(s),x) = &delta;<sub>ext</sub>(&delta;<sub>int</sub>(s,0,x).</li>
<li>&lambda; : S &rarr; Y<sup>b</sup> is the output function. Y<sup>b</sup> is the set of bags over elements in Y. When the time elapsed since the last output function is equal to ta(s), then &lambda; is automatically executed.</li>
<li>ta : S &rarr; R<sub>0</sub><sup>+</sup> &cup; &infin; is the time advance function.</li>
</ul>

<p>
The formal definition of a coupled model is described as:
</p>

<p>
M = &lt; <b>X</b>, <b>Y</b>, <b>C</b>, <b>EIC</b>, <b>EOC</b>, <b>IC</b> &gt;
</p>

<p>
where:
</p>

<ul class="org-ul">
<li><b>X</b> is the input set, usually defined as the set of pairs port-value (see DEVS with ports in [1])..</li>
<li><b>Y</b> is the output set, usually defined as the set of pairs port-value (see DEVS with ports in [1])..</li>
<li><b>C</b> is the set of DEVS component models (atomic or coupled). Note that <b>C</b> makes this definition recursive.</li>
<li><b>EIC</b> is the external input coupling relation, from external input ports of M to component input ports of <b>C</b>.</li>
<li><b>EOC</b> is the external output coupling relation, from component output ports of <b>C</b> to external output ports of M.</li>
<li><b>IC</b> is the internal coupling relation, from component output ports of c<sub>i</sub> &isin; <b>C</b> to component output ports of c<sub>j</sub> &isin; <b>C</b>, provided that i &ne; j.</li>
</ul>

<p>
Given the recursive definition of <b>M</b>, a coupled model can itself be a part of a component in a larger coupled model system giving rise to a hierarchical DEVS model construction.
</p>
</div>



<div id="outline-container-orgcc910ad" class="outline-5">
<h5 id="orgcc910ad">EXAMPLE 1</h5>
<div class="outline-text-5" id="text-orgcc910ad">
<p>
A processor atomic model consumes a job j. When the processor receives a job through an input port, thus the processor remains busy until the processing time j<sub>p</sub> is finished. Then it sends the job through an output port.
</p>

<p>
The processor model can be formally described as
</p>

<p>
Processor=〈X,S,Y,δ<sub>int</sub>,δ<sub>ext</sub>,δ<sub>con</sub>,λ,ta〉
</p>

<ul class="org-ul">
<li><b>X</b> = {(in, j ∈ <b>J</b>)}, where <b>J</b> is a set of Jobs.</li>
<li><b>S</b> = phase={"busy","passive"} × σ ∈ R<sub>0</sub><sup>+</sup> × j ∈ <b>J</b></li>
<li><b>Y</b> = {(out, j ∈ <b>J</b>)}</li>
<li>ta(phase,σ,j) = σ</li>
<li>λ(phase,σ,j) = j</li>
<li>δ<sub>int</sub>(phase,σ,j) = ("passive", ∞, ∅)</li>
<li>δ<sub>ext</sub>(phase,σ,j,e,(in,j')) = {("busy",j<sub>p</sub>',j')  if  phase="passive", ("busy",σ-e,j)  if  phase="busy"</li>
<li>δ<sub>con</sub>(phase,σ,j,(in,j')) = δ<sub>ext</sub>(δ<sub>int</sub>(phase,σ,j),0,(in,j'))</li>
</ul>
</div>
</div>

<div id="outline-container-org36e4036" class="outline-5">
<h5 id="org36e4036">EXAMPLE 2</h5>
<div class="outline-text-5" id="text-org36e4036">
<p>
Figure 2 shows an example of a DEVS coupled model with three components, M1, M2 y M3, as well as their couplings. These models are interconnected through the corresponding I/O ports presented in the Figure. The models are connected to the external coupled models through the EIC and EOC connectors. M1, M2 and M3 can be atomic or coupled models.
</p>

<p>
<img src="./fig/coupled.png" alt="coupled.png" />
Figure 2. A DEVS coupled model
</p>

<p>
Following the previous coupled model definition, the model in Figure 2 can be formally defined as:
</p>

<p>
N =〈 <b>X</b>, <b>Y</b>, <b>C</b>, <b>EIC</b>, <b>EOC</b>, <b>IC</b> 〉
</p>

<p>
where:
</p>

<ul class="org-ul">
<li><b>X</b> is the set of input events.</li>
<li><b>Y</b> is the set of output events.</li>
<li><b>C</b> = {M1,M2,M3}</li>
<li><b>EIC</b> = {(N,in)→(M1,in)}</li>
<li><b>EOC</b> = {(M3,out)→(N,out)}</li>
<li><b>IC</b> = {(M1,out)→(M2,in),(M2,out)→(M3,in)}</li>
</ul>
</div>
</div>

<div id="outline-container-orgb613318" class="outline-5">
<h5 id="orgb613318">EXAMPLE 3</h5>
<div class="outline-text-5" id="text-orgb613318">
<p>
The Experimental frame – Processor model is usually presented as one of the initial examples to start to practice with DEVS modeling and simulation. It is a DEVS coupled model consisting of three atomic models and one coupled model (see Figure 3).
</p>

<p>
<img src="./fig/efp.png" alt="efp.png" />
Figure 3. Experimental frame (ef)-processor (p) model; boxes: models; arrows: couplings; arrow labels: input/output port names.
</p>

<p>
The Generator atomic model generates job-messages at fixed time intervals and sends them via the "out" port. The Transducer atomic model accepts job-messages from the generator at its "arrived" port and remembers their arrival time instances. It also accepts job-messages at the "solved" port. When a message arrives at the "solved" port, the transducer matches this job with the previous job that had arrived on the "arrived" port earlier and calculates their time difference. Together, these two atomic models form an Experimental frame coupled model. The experimental frame sends the generators job messages on the "out" port and forwards the messages received on its "in" port to the transducers "solved" port. The transducer observes the response (in this case the turnaround time) of messages that are injected into an observed system. The observed system in this case is the Processor atomic model. A processor accepts jobs at its "in" port and sends them via "out" port again after some finite, but non-zero time period. If the processor is busy when a new job arrives, the processor discards it. Finally the transducer stops the generation of jobs by sending any event from its "out" port to the "stop" port at the generator, after a given simulation time interval.
</p>

<p>
Based on Figure 3, we can define the coupled model for this example as:
</p>

<p>
EFP=〈 <b>X</b>, <b>Y</b>, <b>C</b>, <b>EIC</b>, <b>EOC</b>, <b>IC</b> 〉
</p>

<p>
where:
</p>

<ul class="org-ul">
<li><b>X</b> = ∅.</li>
<li><b>Y</b> = ∅.</li>
<li><b>C</b> = {EF,P}</li>
<li><b>EIC</b> = ∅</li>
<li><b>EOC</b> = ∅</li>
<li><b>IC</b> = {(EF,out)→(P,in),(P,out)→(EF,in)}</li>
</ul>

<p>
The Experimental Frame coupled model can be defined as:
</p>

<p>
EF=〈 <b>X</b>, <b>Y</b>, <b>C</b>, <b>EIC</b>, <b>EOC</b>, <b>IC</b> 〉
</p>

<p>
where:
</p>

<ul class="org-ul">
<li><b>X</b> = {(in,j∈J)}, where J is a set of Jobs.</li>
<li><b>Y</b> = {(out,j∈J)}, where J is a set of Jobs.</li>
<li><b>C</b> = {G,T}</li>
<li><b>EIC</b> = {(EF,in)→(T,solved)}</li>
<li><b>EOC</b> = {(G,out)→(EF,out)}</li>
<li><b>IC</b> = {(G,out)→(T,arrived),(T,out)→(Generator,stop)}</li>
</ul>

<p>
We have defined the behavior of the Processor model in a previous example. Now, we describe the functionality of both the Generator and Transduced models. The Generator model can be formally described as
</p>

<p>
Generator=〈 <b>X</b>, <b>S</b>, <b>Y</b>, δ<sub>int</sub>, δ<sub>ext</sub>, δ<sub>con</sub>, λ, ta 〉
</p>

<ul class="org-ul">
<li><b>X</b> = {(stop,ν)}, where ν is any event</li>
<li><b>S</b> = (phase={"active","passive"})×σ∈R0+×i=1,2,…,N:ji∈J</li>
<li><b>Y</b> = {(out,ji∈ J)}</li>
<li>ta(phase,σ,i) = σ</li>
<li>λ(phase,σ,i) = ji</li>
<li>δ<sub>int</sub>(phase,σ,i) = ("active",σ,i+1)</li>
<li>δ<sub>ext</sub>(phase,σ,i,e,(in,ν)) = ("passive",∞,i)</li>
<li>δ<sub>con</sub>(phase,σ,i,(in,ν)) = δ<sub>ext</sub>(δ<sub>int</sub>(phase,σ,i),0,(in,ν))</li>
</ul>

<p>
The Transducer model can be formally described as
</p>

<p>
Transducer=〈 <b>X</b>, <b>S</b>, <b>Y</b>, δ<sub>int</sub>, δ<sub>ext</sub>, δ<sub>con</sub>, λ, ta 〉
</p>

<ul class="org-ul">
<li><b>X</b> = {(arrived,j∈J),(solved,j∈J}, where J is a set of jobs</li>
<li><b>S</b> = (phase = {"active","passive"}) × (σ ∈ R<sub>0</sub><sup>+ </sup>) × (clock ∈ R<sub>0</sub><sup>+</sup> × J<sub>A</sub>∈J × J<sub>S</sub>∈J
where J<sub>A</sub> and J<sub>S</sub> are sets of arrived and solved jobs, respectively.</li>
<li><b>Y</b> = {(stop,ν)}, where ν is any event.</li>
<li>ta(phase,σ,clock,J<sub>A</sub>,J<sub>S</sub>) = σ</li>
<li>λ(phase,σ,clock,J<sub>A</sub>,J<sub>S</sub>) = ν</li>
<li>δ<sub>int</sub>(phase,σ,clock,J<sub>A</sub>,J<sub>S</sub>) = ("passive",∞,clock+σ,J<sub>A</sub>,J<sub>S</sub>)</li>
<li>δext(phase,σ,clock,J<sub>A</sub>,J<sub>S</sub>,e,(arrived,j<sup>a</sup>),(solved,j<sup>s</sup>))= &#x2026;
&#x2026; = (active,σ-e,clock+e,J<sub>A</sub>={j<sup>a</sup>,J<sub>A</sub>} if j<sup>a</sup>≠∅, J<sub>S</sub>={j<sup>s</sup>,J<sub>S</sub>}:j<sub>t</sub><sup>s</sup>=clock if j<sup>s</sup>≠∅)
, where the time in which the job is solved is set to clock with j<sub>t</sub><sup>s</sup> = clock.</li>
<li>δ<sub>con</sub>(phase,σ,clock,J<sub>A</sub>,J<sub>S</sub>,(arrived,j<sup>a</sup>),(solved,j<sup>s</sup>))=δ<sub>ext</sub>(δ<sub>int</sub>(phase,σ,clock,J<sub>A</sub>,J<sub>S</sub>),0,(arrived,j<sup>a</sup>),(solved,j<sup>s</sup>))</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd9be9a9" class="outline-3">
<h3 id="orgd9be9a9">Bibliography</h3>
<div class="outline-text-3" id="text-orgd9be9a9">
<ol class="org-ol">
<li>Zeigler, B. P.; Muzy, A. &amp; Kofman, E. Theory of modeling and simulation: discrete event &amp; iterative system computational foundations Academic press, 2018.</li>
<li>Mittal, S. &amp; Risco-Martín, J. L. Netcentric system of systems engineering with DEVS unified process CRC Press, 2013.</li>
<li>Vangheluwe, H. DEVS as a common denominator for multi-formalism hybrid systems modelling CACSD. Conference Proceedings. IEEE International Symposium on Computer-Aided Control System Design (Cat. No.00TH8537), 2000, 129-134</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orge7652da" class="outline-2">
<h2 id="orge7652da">Getting started with xDEVS</h2>
<div class="outline-text-2" id="text-orge7652da">
<p>
In this section, we introduce the basics of xDEVS by developing a simple Ping Pong model. This model is inspired by the DEVS formalism as described on Wikipedia: <a href="https://en.wikipedia.org/wiki/DEVS">https://en.wikipedia.org/wiki/DEVS</a>
</p>


<div class="figure">
<p><img src="./fig/devs-pingpong.jpg" alt="devs-pingpong.jpg" />
</p>
</div>

<p>
The Ping Pong model simulates two players hitting a ball back and forth. We will define the model's behavior using output, internal transition, and external transition functions.
</p>
</div>

<div id="outline-container-orgceb1795" class="outline-3">
<h3 id="orgceb1795">Output Function</h3>
<div class="outline-text-3" id="text-orgceb1795">
<p>
The output function \(\lambda\) determines the output based on the current state:
</p>

<p>
\[
\lambda(\text{Send}, \sigma) = !\text{send}
\]
\[
\lambda(\text{Wait}, \sigma) = \emptyset
\]
</p>

<p>
This is implemented in Python as follows:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Version 1.0</span>
<span style="color: #00bfff;">def</span> <span style="color: #daa520;">lambdaf</span>(<span style="color: #00bfff;">self</span>):
    <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.phase_is(<span style="color: #deb887;">"Send"</span>):
        <span style="color: #00bfff;">self</span>.o_send.add(<span style="color: #deb887;">"!send"</span>)
        <span style="color: #00bfff;">print</span>(f<span style="color: #deb887;">"{self.name} sends the ball"</span>)

<span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Version 2.0</span>
<span style="color: #00bfff;">def</span> <span style="color: #daa520;">lambdaf</span>(<span style="color: #00bfff;">self</span>):
    <span style="color: #00bfff;">self</span>.o_send.add(<span style="color: #deb887;">"!send"</span>)
    <span style="color: #00bfff;">print</span>(f<span style="color: #deb887;">"{self.name} sends the ball"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f02af6" class="outline-3">
<h3 id="org7f02af6">Internal Transition Function</h3>
<div class="outline-text-3" id="text-org7f02af6">
<p>
The internal transition function \(\delta_{int}\) updates the state based on the elapsed time:
</p>

<p>
\[
\delta_{int}(\text{Send}, \sigma) = (\text{Wait}, \infty)
\]
\[
\delta_{int}(\text{Wait}, \sigma) = (\text{Send}, 0.1)
\]
</p>

<p>
Implemented in Python:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Version 1.0</span>
<span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
    <span style="color: #00bfff;">if</span> (<span style="color: #00bfff;">self</span>.phase == <span style="color: #deb887;">"Wait"</span>):
        <span style="color: #00bfff;">self</span>.hold_in(<span style="color: #deb887;">"Send"</span>, 0.1)
    <span style="color: #00bfff;">elif</span> (<span style="color: #00bfff;">self</span>.phase == <span style="color: #deb887;">"Send"</span>):
        <span style="color: #00bfff;">self</span>.hold_in(<span style="color: #deb887;">"Wait"</span>, INFINITY)

<span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Version 2.0</span>
<span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
    <span style="color: #00bfff;">if</span> (<span style="color: #00bfff;">self</span>.phase == <span style="color: #deb887;">"Send"</span>):
        <span style="color: #00bfff;">self</span>.hold_in(<span style="color: #deb887;">"Wait"</span>, INFINITY)

<span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Version 3.0</span>
<span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
    <span style="color: #00bfff;">self</span>.hold_in(<span style="color: #deb887;">"Wait"</span>, INFINITY)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1197072" class="outline-3">
<h3 id="org1197072">External Transition Function</h3>
<div class="outline-text-3" id="text-org1197072">
<p>
The external transition function \(\delta_{ext}\) modifies the state in response to external events:
</p>

<p>
\[
\delta_{ext}(((\text{Wait}, \sigma), t_e), ?\text{receive}) = (\text{Send}, 0.1)
\]
</p>

<p>
Python implementation:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Version 1.0</span>
<span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltext</span>(<span style="color: #00bfff;">self</span>, e):
    <span style="color: #00bfff;">self</span>.continuef(e) <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">VERY IMPORTANT!!!</span>
    <span style="color: #00bfff;">print</span>(f<span style="color: #deb887;">"{self.name} receives the ball"</span>)
    <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.i_receive:
        <span style="color: #00bfff;">self</span>.hold_in(<span style="color: #deb887;">"Send"</span>, 0.1)

<span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Version 2.0</span>
<span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltext</span>(<span style="color: #00bfff;">self</span>, e):
    <span style="color: #00bfff;">self</span>.continuef(e) <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">VERY IMPORTANT!!!</span>
    <span style="color: #00bfff;">print</span>(f<span style="color: #deb887;">"{self.name} receives the ball"</span>)
    <span style="color: #00bfff;">self</span>.hold_in(<span style="color: #deb887;">"Send"</span>, 0.1)
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a08d8a" class="outline-3">
<h3 id="org8a08d8a">Complete model implementation</h3>
<div class="outline-text-3" id="text-org8a08d8a">
<p>
The complete Python implementation of the Ping Pong model using xDEVS is as follows:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00bfff;">import</span> logging

<span style="color: #00bfff;">from</span> xdevs <span style="color: #00bfff;">import</span> get_logger
<span style="color: #00bfff;">from</span> xdevs.models <span style="color: #00bfff;">import</span> Atomic, Coupled, Port, INFINITY
<span style="color: #00bfff;">from</span> xdevs.sim <span style="color: #00bfff;">import</span> Coordinator

<span style="color: #4eee94;">logger</span> = get_logger(<span style="color: #f08080;">__name__</span>, logging.INFO)

PHASE_SEND:<span style="color: #f08080;">str</span> = <span style="color: #deb887;">"Send"</span>
PHASE_WAIT:<span style="color: #f08080;">str</span> = <span style="color: #deb887;">"Wait"</span>

<span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">Player</span>(Atomic):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name, sender:<span style="color: #f08080;">bool</span>=<span style="color: #a2cd5a;">False</span>):
        Atomic.__init__(<span style="color: #00bfff;">self</span>, name)
        <span style="color: #00bfff;">self</span>.sender = sender
        <span style="color: #00bfff;">self</span>.i_receive = Port(<span style="color: #f08080;">str</span>, <span style="color: #deb887;">"i_receive"</span>)
        <span style="color: #00bfff;">self</span>.o_send = Port(<span style="color: #f08080;">str</span>, <span style="color: #deb887;">"o_send"</span>)
        <span style="color: #00bfff;">self</span>.add_in_port(<span style="color: #00bfff;">self</span>.i_receive)
        <span style="color: #00bfff;">self</span>.add_out_port(<span style="color: #00bfff;">self</span>.o_send)

    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">initialize</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">if</span> (<span style="color: #00bfff;">self</span>.sender):
            <span style="color: #00bfff;">self</span>.hold_in(PHASE_SEND, 0.1)
        <span style="color: #00bfff;">else</span>:
            <span style="color: #00bfff;">self</span>.hold_in(PHASE_WAIT, INFINITY)

    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">exit</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">pass</span>

    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">lambdaf</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">if</span> (<span style="color: #00bfff;">self</span>.phase == PHASE_SEND):
            <span style="color: #00bfff;">self</span>.o_send.add(<span style="color: #deb887;">"!send"</span>)
            logger.info(f<span style="color: #deb887;">"{self.name} sends the ball"</span>)

    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">if</span> (<span style="color: #00bfff;">self</span>.phase == PHASE_SEND):
            <span style="color: #00bfff;">self</span>.hold_in(PHASE_WAIT, INFINITY)

    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltext</span>(<span style="color: #00bfff;">self</span>, e):
        <span style="color: #00bfff;">self</span>.continuef(e)
        logger.info(f<span style="color: #deb887;">"{self.name} receives the ball"</span>)
        <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.i_receive:
            <span style="color: #00bfff;">self</span>.hold_in(PHASE_SEND, 0.1)

<span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">PingPong</span>(Coupled):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>):
        Coupled.__init__(<span style="color: #00bfff;">self</span>)
        <span style="color: #4eee94;">player1</span> = Player(<span style="color: #deb887;">"Player A"</span>, <span style="color: #a2cd5a;">True</span>)
        <span style="color: #4eee94;">player2</span> = Player(<span style="color: #deb887;">"Player B"</span>)
        <span style="color: #00bfff;">self</span>.add_component(player1)
        <span style="color: #00bfff;">self</span>.add_component(player2)
        <span style="color: #00bfff;">self</span>.add_coupling(player1.o_send, player2.i_receive)
        <span style="color: #00bfff;">self</span>.add_coupling(player2.o_send, player1.i_receive)

<span style="color: #00bfff;">if</span> <span style="color: #f08080;">__name__</span> == <span style="color: #deb887;">"__main__"</span>:
    <span style="color: #4eee94;">model</span> = PingPong()
    <span style="color: #4eee94;">coord</span> = Coordinator(model)
    coord.initialize()
    coord.simulate(num_iters=10)
    coord.<span style="color: #a2cd5a;">exit</span>()
</pre>
</div>
</div>
</div>

<div id="outline-container-org1465cbd" class="outline-3">
<h3 id="org1465cbd">Running the model</h3>
<div class="outline-text-3" id="text-org1465cbd">
<p>
To run the model, follow these steps on Ubuntu 22.04:
</p>

<pre class="example">
sudo apt install python3 python3-pip
pip3 install -U xdevs
python3 ping-pong.py

Player A sends the ball
Player B receives the ball
Player B sends the ball
Player A receives the ball
Player A sends the ball
Player B receives the ball
...
</pre>
</div>
</div>
</div>

<div id="outline-container-org7c55f93" class="outline-2">
<h2 id="org7c55f93">Building models in xDEVS</h2>
<div class="outline-text-2" id="text-org7c55f93">
</div>
<div id="outline-container-org6ced4fb" class="outline-3">
<h3 id="org6ced4fb">Atomic models</h3>
<div class="outline-text-3" id="text-org6ced4fb">
<p>
In xDEVS, atomic models are the fundamental building blocks for constructing simulation models. An atomic model in xDEVS encapsulates the behavior of a system component that cannot be further decomposed into smaller components. It defines the state changes and interactions of the component in response to internal and external events.
</p>
</div>

<div id="outline-container-orga81c5f3" class="outline-4">
<h4 id="orga81c5f3">Structure of an atomic model</h4>
<div class="outline-text-4" id="text-orga81c5f3">
<p>
The <code>Atomic</code> class, derived from the <code>Component</code> class and marked as an abstract base class, serves as the base class for all atomic models in xDEVS. Here's a breakdown of its key components and functionalities:
</p>

<ul class="org-ul">
<li><b>Initialization</b>: The constructor initializes the atomic model, setting its name and initializing its phase to <code>passive</code> and its time advance (<code>sigma</code>) to infinity. This represents a state where the model is waiting indefinitely for an external event.</li>

<li><b>Time Advance Function (<code>ta</code>)</b>: This property method returns the time until the next scheduled internal transition (<code>sigma</code>). It dictates how long the model stays in its current state before an internal transition occurs.</li>

<li><b>Internal Transition (<code>deltint</code>)</b>: This abstract method must be implemented by all subclasses. It defines the state changes that occur when an internal event is triggered after the elapse of the time advance.</li>

<li><b>External Transition (<code>deltext</code>)</b>: This abstract method handles state changes in response to external events. It takes the elapsed time (<code>e</code>) since the last transition as an argument, allowing the model to update its state based on external inputs.</li>

<li><b>Output Function (<code>lambdaf</code>)</b>: Another abstract method that specifies the output of the model just before an internal transition occurs. This function is crucial for sending outputs to other models in a coupled model configuration.</li>

<li><b>Confluent Transition (<code>deltcon</code>)</b>: By default, this method handles the simultaneous occurrence of internal and external events. It first processes the internal transition and then the external transition with zero elapsed time.</li>

<li><b>State Management Methods</b>: The methods <code>hold_in</code>, <code>activate</code>, <code>passivate</code>, and <code>continuef</code> are utility functions to manage the model's state and timing:
<ul class="org-ul">
<li><code>hold_in</code>: Sets the model's phase and schedules the next internal transition.</li>
<li><code>activate</code>: Immediately triggers an internal transition by setting <code>sigma</code> to zero.</li>
<li><code>passivate</code>: Puts the model into a passive state with an infinite wait time.</li>
<li><code>continuef</code>: Adjusts the time advance by reducing it by the elapsed time <code>e</code>, useful for resuming after a paused state.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org2ef1e6c" class="outline-4">
<h4 id="org2ef1e6c">Implementing an atomic model</h4>
<div class="outline-text-4" id="text-org2ef1e6c">
<p>
To implement an atomic model in xDEVS, you need to subclass the <code>Atomic</code> class and provide concrete implementations for the <code>deltint</code>, <code>deltext</code>, and <code>lambdaf</code> methods. Each method should define how the model reacts to different types of events and manages its state transitions effectively.
</p>

<p>
Here is a simple example of an atomic model that increments a counter:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">CounterModel</span>(Atomic):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name=<span style="color: #a2cd5a;">None</span>):
        <span style="color: #f08080;">super</span>().__init__(name)
        <span style="color: #00bfff;">self</span>.count = 0
        <span style="color: #00bfff;">self</span>.hold_in(<span style="color: #deb887;">"active"</span>, 1)  <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Active for 1 time unit</span>

    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.count += 1
        <span style="color: #00bfff;">self</span>.hold_in(<span style="color: #deb887;">"active"</span>, 1)  <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Schedule next increment</span>

    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltext</span>(<span style="color: #00bfff;">self</span>, e):
        <span style="color: #00bfff;">self</span>.continuef(e)  <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Continue countdown</span>

    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">lambdaf</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">pass</span> <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">No output</span>

    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__str__</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">return</span> f<span style="color: #deb887;">"CounterModel(name={self.name}, count={self.count})"</span>
</pre>
</div>

<p>
This model demonstrates basic internal and external transitions. It continuously counts upwards.
</p>
</div>
</div>

<div id="outline-container-orga6c905e" class="outline-4">
<h4 id="orga6c905e">Ports</h4>
<div class="outline-text-4" id="text-orga6c905e">
<p>
In xDEVS, ports are essential for enabling communication between atomic models and facilitating the flow of events in a coupled model configuration. Ports are used to send and receive messages, allowing models to interact with each other.
</p>

<ul class="org-ul">
<li><i>Input Ports</i>: These ports receive messages from other models. Each input port is associated with a specific type of message it can accept. When an external event occurs, the message is placed in the corresponding input port, and the <code>deltext</code> method is invoked to handle the event.</li>

<li><i>Output Ports</i>: These ports send messages to other models. Before an internal transition occurs, the <code>lambdaf</code> method generates the output, which is then placed in the appropriate output port. The coupled model configuration ensures that these messages are routed to the correct input ports of other models.</li>
</ul>

<p>
To define ports in an atomic model, you need to create instances of the <code>Port</code> class and add them to the model using the <code>add_in_port</code> and <code>add_out_port</code> methods. Here is an example demonstrating the use of ports in atomic models:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">Generator</span>(Atomic):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name, period):
        <span style="color: #f08080;">super</span>().__init__(name)
        <span style="color: #00bfff;">self</span>.i_stop = Port(Job, <span style="color: #deb887;">"i_stop"</span>)
        <span style="color: #00bfff;">self</span>.o_out = Port(Job, <span style="color: #deb887;">"o_out"</span>)
        
        <span style="color: #00bfff;">self</span>.add_in_port(<span style="color: #00bfff;">self</span>.i_stop)
        <span style="color: #00bfff;">self</span>.add_out_port(<span style="color: #00bfff;">self</span>.o_out)
        
        <span style="color: #00bfff;">self</span>.period = period
        <span style="color: #00bfff;">self</span>.job_counter = 1
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">initialize</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.hold_in(PHASE_ACTIVE, <span style="color: #00bfff;">self</span>.period)
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.job_counter += 1
        <span style="color: #00bfff;">self</span>.hold_in(PHASE_ACTIVE, <span style="color: #00bfff;">self</span>.period)
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltext</span>(<span style="color: #00bfff;">self</span>, e):
        <span style="color: #00bfff;">self</span>.passivate()
    
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">lambdaf</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.o_out.add(Job(<span style="color: #f08080;">str</span>(<span style="color: #00bfff;">self</span>.job_counter)))

<span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">Processor</span>(Atomic):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name, proc_time):
        <span style="color: #f08080;">super</span>().__init__(name)
        
        <span style="color: #00bfff;">self</span>.i_in = Port(Job, <span style="color: #deb887;">"i_in"</span>)
        <span style="color: #00bfff;">self</span>.o_out = Port(Job, <span style="color: #deb887;">"o_out"</span>)
        
        <span style="color: #00bfff;">self</span>.add_in_port(<span style="color: #00bfff;">self</span>.i_in)
        <span style="color: #00bfff;">self</span>.add_out_port(<span style="color: #00bfff;">self</span>.o_out)

        <span style="color: #00bfff;">self</span>.current_job = <span style="color: #a2cd5a;">None</span>
        <span style="color: #00bfff;">self</span>.proc_time = proc_time
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">initialize</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.passivate()
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.passivate()
    
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltext</span>(<span style="color: #00bfff;">self</span>, e):
        <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.phase == PHASE_PASSIVE:
            <span style="color: #00bfff;">self</span>.current_job = <span style="color: #00bfff;">self</span>.i_in.get()
            <span style="color: #00bfff;">self</span>.hold_in(PHASE_ACTIVE, <span style="color: #00bfff;">self</span>.proc_time)
        <span style="color: #00bfff;">self</span>.continuef(e)
    
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">lambdaf</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.o_out.add(<span style="color: #00bfff;">self</span>.current_job)
</pre>
</div>

<p>
In this example, the <code>Generator</code> model has input ports <code>i_start</code> and <code>i_stop</code> and an output port <code>o_out</code>. The <code>Processor</code> model has an input port <code>i_in</code> and an output port <code>o_out</code>. These ports facilitate the communication between the <code>Generator</code> and <code>Processor</code> models, allowing them to exchange <code>Job</code> messages.
</p>

<p>
By defining and using ports, you can create complex coupled models where multiple atomic models interact seamlessly, enabling sophisticated simulations of system behaviors.
</p>
</div>
</div>
</div>

<div id="outline-container-org7d650f4" class="outline-3">
<h3 id="org7d650f4">Coupled models</h3>
<div class="outline-text-3" id="text-org7d650f4">
<p>
In xDEVS, coupled models are composite models that consist of multiple atomic and/or other coupled models. They define the structure and interaction of these submodels, enabling the construction of complex systems by combining simpler components. Coupled models manage the routing of messages between their submodels and handle the overall coordination of events.
</p>
</div>

<div id="outline-container-org62efe6c" class="outline-4">
<h4 id="org62efe6c">Structure of a coupled model</h4>
<div class="outline-text-4" id="text-org62efe6c">
<p>
The <code>Coupled</code> class, derived from the <code>Component</code> class, serves as the base class for all coupled models in xDEVS. Here are the key components and functionalities of a coupled model:
</p>

<ul class="org-ul">
<li><i>Submodels</i>: A coupled model contains a collection of submodels, which can be either atomic models or other coupled models. These submodels are added to the coupled model using the <code>add_component</code> method.</li>

<li><i>Ports</i>: Similar to atomic models, coupled models have input and output ports. These ports are used to receive external messages and send messages to other models outside the coupled model.</li>

<li><i>Couplings</i>: Couplings define the connections between the ports of submodels and the ports of the coupled model. There are three types of couplings:
<ul class="org-ul">
<li><i>Internal Couplings</i>: Connect the output ports of one submodel to the input ports of another submodel within the same coupled model.</li>
<li>/External Input Couplings (EIC)*: Connect the input ports of the coupled model to the input ports of its submodels.</li>
<li>/External Output Couplings (EOC)*: Connect the output ports of the submodels to the output ports of the coupled model.</li>
</ul></li>

<li><i>Routing</i>: The coupled model is responsible for routing messages according to the defined couplings. When a message arrives at an input port, it is routed to the appropriate submodel(s) based on the EIC. Similarly, when a submodel generates an output, it is routed to other submodels or the coupled model's output ports based on the internal couplings and EOC.</li>
</ul>
</div>
</div>

<div id="outline-container-org47205fb" class="outline-4">
<h4 id="org47205fb">Implementing a coupled model</h4>
<div class="outline-text-4" id="text-org47205fb">
<p>
To implement a coupled model in xDEVS, you need to subclass the <code>Coupled</code> class and define its submodels and couplings. Here is an example of a simple coupled model that combines a <code>Generator</code> and a <code>Processor</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">BasicCoupledModel</span>(Coupled):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name):
        <span style="color: #f08080;">super</span>().__init__(name)
        
        <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Define ports</span>
        <span style="color: #00bfff;">self</span>.i_in = Port(Job, <span style="color: #deb887;">"i_in"</span>)
        <span style="color: #00bfff;">self</span>.o_out = Port(Job, <span style="color: #deb887;">"o_out"</span>)        
        <span style="color: #00bfff;">self</span>.add_in_port(<span style="color: #00bfff;">self</span>.i_in)
        <span style="color: #00bfff;">self</span>.add_out_port(<span style="color: #00bfff;">self</span>.o_out)

        <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Create submodels</span>
        <span style="color: #00bfff;">self</span>.generator = Generator(<span style="color: #deb887;">"Generator"</span>, period=5)
        <span style="color: #00bfff;">self</span>.processor = Processor(<span style="color: #deb887;">"Processor"</span>, proc_time=3)
        
        <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Add submodels to the coupled model</span>
        <span style="color: #00bfff;">self</span>.add_component(<span style="color: #00bfff;">self</span>.generator)
        <span style="color: #00bfff;">self</span>.add_component(<span style="color: #00bfff;">self</span>.processor)
        
        <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Define couplings</span>
        <span style="color: #00bfff;">self</span>.add_coupling(<span style="color: #00bfff;">self</span>.generator.o_out, <span style="color: #00bfff;">self</span>.processor.i_in)  <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">Internal coupling</span>
        <span style="color: #00bfff;">self</span>.add_coupling(<span style="color: #00bfff;">self</span>.processor.o_out, <span style="color: #00bfff;">self</span>.o_out)           <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">External output coupling</span>
        <span style="color: #00bfff;">self</span>.add_coupling(<span style="color: #00bfff;">self</span>.i_in, <span style="color: #00bfff;">self</span>.generator.i_stop)           <span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">External input coupling</span>

</pre>
</div>

<p>
In this example, the <code>BasicCoupledModel</code> class defines a coupled model that includes a <code>Generator</code> and a <code>Processor</code> as submodels. The couplings are set up to route messages from the generator to the processor and from the processor to the coupled model's output port. Additionally, an external input coupling is defined to allow external messages to stop the generator.
</p>

<p>
By defining submodels and their couplings, you can create complex systems that simulate the interactions and behaviors of multiple components working together. Coupled models provide a powerful way to build hierarchical and modular simulations in xDEVS.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb612d79" class="outline-3">
<h3 id="orgb612d79">Models configuration</h3>
<div class="outline-text-3" id="text-orgb612d79">
<p>
In this section, we will configure and run a simulation using the xDEVS framework. The provided source code defines several atomic models (Generator, Processor, and Transducer) and a coupled model (Gpt) that combines these atomic models. We will walk through the configuration and execution of the simulation.
</p>

<ol class="org-ol">
<li><b>Importing Required Modules</b>:
The necessary modules and classes are imported, including logging, xDEVS components, and the simulation coordinator.</li>

<li><b>Defining the Job Class</b>:
The <code>Job</code> class represents a job with a name and a timestamp.</li>

<li><b>Defining Atomic Models</b>:
<ul class="org-ul">
<li><b>Generator</b>: Generates jobs at a specified period and sends them to the processor and transducer.</li>
<li><b>Processor</b>: Processes incoming jobs for a specified processing time.</li>
<li><b>Transducer</b>: Observes the system, collects statistics, and logs performance metrics.</li>
</ul></li>

<li><b>Defining the Coupled Model</b>:
The <code>Gpt</code> class is a coupled model that integrates the Generator, Processor, and Transducer models. It sets up the internal and external couplings to route messages between these submodels.</li>

<li><b>Running the Simulation</b>:
The main block of the code creates an instance of the <code>Gpt</code> coupled model, initializes the simulation coordinator, and runs the simulation.</li>
</ol>

<p>
Here is the complete source code for configuring and running the simulation:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #00bfff;">import</span> logging

<span style="color: #00bfff;">from</span> xdevs <span style="color: #00bfff;">import</span> PHASE_ACTIVE, PHASE_PASSIVE, get_logger
<span style="color: #00bfff;">from</span> xdevs.models <span style="color: #00bfff;">import</span> Atomic, Coupled, Port
<span style="color: #00bfff;">from</span> xdevs.sim <span style="color: #00bfff;">import</span> Coordinator

<span style="color: #4eee94;">logger</span> = get_logger(<span style="color: #f08080;">__name__</span>, logging.DEBUG)

<span style="color: #4eee94;">PHASE_DONE</span> = <span style="color: #deb887;">"done"</span>

<span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">Job</span>:
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name):
        <span style="color: #00bfff;">self</span>.name = name
        <span style="color: #00bfff;">self</span>.time = 0

<span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">Generator</span>(Atomic):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name, period):
        <span style="color: #f08080;">super</span>().__init__(name)
        <span style="color: #00bfff;">self</span>.i_stop = Port(Job, <span style="color: #deb887;">"i_stop"</span>)
        <span style="color: #00bfff;">self</span>.o_out = Port(Job, <span style="color: #deb887;">"o_out"</span>)
        
        <span style="color: #00bfff;">self</span>.add_in_port(<span style="color: #00bfff;">self</span>.i_stop)
        <span style="color: #00bfff;">self</span>.add_out_port(<span style="color: #00bfff;">self</span>.o_out)
        
        <span style="color: #00bfff;">self</span>.period = period
        <span style="color: #00bfff;">self</span>.job_counter = 1
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">initialize</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.hold_in(PHASE_ACTIVE, <span style="color: #00bfff;">self</span>.period)
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">exit</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">pass</span>
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.job_counter += 1
        <span style="color: #00bfff;">self</span>.hold_in(PHASE_ACTIVE, <span style="color: #00bfff;">self</span>.period)
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltext</span>(<span style="color: #00bfff;">self</span>, e):
        <span style="color: #00bfff;">self</span>.passivate()
    
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">lambdaf</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.o_out.add(Job(<span style="color: #f08080;">str</span>(<span style="color: #00bfff;">self</span>.job_counter)))

<span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">Processor</span>(Atomic):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name, proc_time):
        <span style="color: #f08080;">super</span>().__init__(name)
        
        <span style="color: #00bfff;">self</span>.i_in = Port(Job, <span style="color: #deb887;">"i_in"</span>)
        <span style="color: #00bfff;">self</span>.o_out = Port(Job, <span style="color: #deb887;">"o_out"</span>)
        
        <span style="color: #00bfff;">self</span>.add_in_port(<span style="color: #00bfff;">self</span>.i_in)
        <span style="color: #00bfff;">self</span>.add_out_port(<span style="color: #00bfff;">self</span>.o_out)

        <span style="color: #00bfff;">self</span>.current_job = <span style="color: #a2cd5a;">None</span>
        <span style="color: #00bfff;">self</span>.proc_time = proc_time
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">initialize</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.passivate()
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">exit</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">pass</span>
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.passivate()
    
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltext</span>(<span style="color: #00bfff;">self</span>, e):
        <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.phase == PHASE_PASSIVE:
            <span style="color: #00bfff;">self</span>.current_job = <span style="color: #00bfff;">self</span>.i_in.get()
            <span style="color: #00bfff;">self</span>.hold_in(PHASE_ACTIVE, <span style="color: #00bfff;">self</span>.proc_time)
        <span style="color: #00bfff;">self</span>.continuef(e)
    
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">lambdaf</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.o_out.add(<span style="color: #00bfff;">self</span>.current_job)

<span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">Transducer</span>(Atomic):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name, obs_time):
        <span style="color: #f08080;">super</span>().__init__(name)
        
        <span style="color: #00bfff;">self</span>.i_arrived = Port(Job, <span style="color: #deb887;">"i_arrived"</span>)
        <span style="color: #00bfff;">self</span>.i_solved = Port(Job, <span style="color: #deb887;">"i_solved"</span>)
        <span style="color: #00bfff;">self</span>.o_out = Port(Job, <span style="color: #deb887;">"o_out"</span>)
        
        <span style="color: #00bfff;">self</span>.add_in_port(<span style="color: #00bfff;">self</span>.i_arrived)
        <span style="color: #00bfff;">self</span>.add_in_port(<span style="color: #00bfff;">self</span>.i_solved)
        <span style="color: #00bfff;">self</span>.add_out_port(<span style="color: #00bfff;">self</span>.o_out)
        
        <span style="color: #00bfff;">self</span>.jobs_arrived = []
        <span style="color: #00bfff;">self</span>.jobs_solved = []
        
        <span style="color: #00bfff;">self</span>.total_ta = 0
        <span style="color: #00bfff;">self</span>.clock = 0
        <span style="color: #00bfff;">self</span>.obs_time = obs_time
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">initialize</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.hold_in(PHASE_ACTIVE, <span style="color: #00bfff;">self</span>.obs_time)
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">exit</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">pass</span>
        
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltint</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">self</span>.clock += <span style="color: #00bfff;">self</span>.sigma
        
        <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.phase == PHASE_ACTIVE:
            <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.jobs_solved:
                <span style="color: #4eee94;">avg_ta</span> = <span style="color: #00bfff;">self</span>.total_ta / <span style="color: #f08080;">len</span>(<span style="color: #00bfff;">self</span>.jobs_solved)
                <span style="color: #4eee94;">throughput</span> = <span style="color: #f08080;">len</span>(<span style="color: #00bfff;">self</span>.jobs_solved) / <span style="color: #00bfff;">self</span>.clock <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.clock &gt; 0 <span style="color: #00bfff;">else</span> 0
            <span style="color: #00bfff;">else</span>:
                <span style="color: #4eee94;">avg_ta</span> = 0
                <span style="color: #4eee94;">throughput</span> = 0
                
            logger.info(<span style="color: #deb887;">"End time: %f"</span> % <span style="color: #00bfff;">self</span>.clock)
            logger.info(<span style="color: #deb887;">"Jobs arrived: %d"</span> % <span style="color: #f08080;">len</span>(<span style="color: #00bfff;">self</span>.jobs_arrived))
            logger.info(<span style="color: #deb887;">"Jobs solved: %d"</span> % <span style="color: #f08080;">len</span>(<span style="color: #00bfff;">self</span>.jobs_solved))
            logger.info(<span style="color: #deb887;">"Average TA: %f"</span> % avg_ta)
            logger.info(<span style="color: #deb887;">"Throughput: %f\n"</span> % throughput)
            
            <span style="color: #00bfff;">self</span>.hold_in(PHASE_DONE, 0)
        <span style="color: #00bfff;">else</span>:
            <span style="color: #00bfff;">self</span>.passivate()
            
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">deltext</span>(<span style="color: #00bfff;">self</span>, e):
        <span style="color: #00bfff;">self</span>.clock += e
        
        <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.phase == PHASE_ACTIVE:
            <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.i_arrived:
                <span style="color: #4eee94;">job</span> = <span style="color: #00bfff;">self</span>.i_arrived.get()
                logger.info(<span style="color: #deb887;">"Starting job %s @ t = %d"</span> % (job.name, <span style="color: #00bfff;">self</span>.clock))
                <span style="color: #4eee94;">job.time</span> = <span style="color: #00bfff;">self</span>.clock
                <span style="color: #00bfff;">self</span>.jobs_arrived.append(job)
                
            <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.i_solved:
                <span style="color: #4eee94;">job</span> = <span style="color: #00bfff;">self</span>.i_solved.get()
                logger.info(<span style="color: #deb887;">"Job %s finished @ t = %d"</span> % (job.name, <span style="color: #00bfff;">self</span>.clock))
                <span style="color: #00bfff;">self</span>.total_ta += <span style="color: #00bfff;">self</span>.clock - job.time
                <span style="color: #00bfff;">self</span>.jobs_solved.append(job)

        <span style="color: #00bfff;">self</span>.continuef(e)
    
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">lambdaf</span>(<span style="color: #00bfff;">self</span>):
        <span style="color: #00bfff;">if</span> <span style="color: #00bfff;">self</span>.phase == PHASE_DONE:
            <span style="color: #00bfff;">self</span>.o_out.add(Job(<span style="color: #deb887;">"null"</span>))

<span style="color: #00bfff;">class</span> <span style="color: #98f5ff;">Gpt</span>(Coupled):
    <span style="color: #00bfff;">def</span> <span style="color: #daa520;">__init__</span>(<span style="color: #00bfff;">self</span>, name, period, obs_time):
        <span style="color: #f08080;">super</span>().__init__(name)

        <span style="color: #00bfff;">if</span> period &lt; 1:
            <span style="color: #00bfff;">raise</span> <span style="color: #98f5ff;">ValueError</span>(<span style="color: #deb887;">"period has to be greater than 0"</span>)

        <span style="color: #00bfff;">if</span> obs_time &lt; 0:
            <span style="color: #00bfff;">raise</span> <span style="color: #98f5ff;">ValueError</span>(<span style="color: #deb887;">"obs_time has to be greater or equal than 0"</span>)

        <span style="color: #4eee94;">gen</span> = Generator(<span style="color: #deb887;">"generator"</span>, period)
        <span style="color: #4eee94;">proc</span> = Processor(<span style="color: #deb887;">"processor"</span>, 3*period)
        <span style="color: #4eee94;">trans</span> = Transducer(<span style="color: #deb887;">"transducer"</span>, obs_time)

        <span style="color: #00bfff;">self</span>.add_component(gen)
        <span style="color: #00bfff;">self</span>.add_component(proc)
        <span style="color: #00bfff;">self</span>.add_component(trans)

        <span style="color: #00bfff;">self</span>.add_coupling(gen.o_out, proc.i_in)
        <span style="color: #00bfff;">self</span>.add_coupling(gen.o_out, trans.i_arrived)
        <span style="color: #00bfff;">self</span>.add_coupling(proc.o_out, trans.i_solved)
        <span style="color: #00bfff;">self</span>.add_coupling(trans.o_out, gen.i_stop)

<span style="color: #00bfff;">if</span> <span style="color: #f08080;">__name__</span> == <span style="color: #deb887;">'__main__'</span>:
    <span style="color: #4eee94;">gpt</span> = Gpt(<span style="color: #deb887;">"gpt"</span>, 1, 100)
    <span style="color: #4eee94;">coord</span> = Coordinator(gpt)
    coord.initialize()
    coord.simulate()
</pre>
</div>

<p>
In this configuration:
</p>
<ul class="org-ul">
<li>The <code>Generator</code> model generates jobs at a specified period and sends them to the <code>Processor</code> and <code>Transducer</code>.</li>
<li>The <code>Processor</code> model processes the jobs for a specified processing time.</li>
<li>The <code>Transducer</code> model observes the system, collects statistics, and logs performance metrics.</li>
<li>The <code>Gpt</code> coupled model integrates these atomic models and sets up the necessary couplings to route messages between them.</li>
<li>The simulation is run by creating an instance of the <code>Gpt</code> model, initializing the coordinator, and calling the <code>simulate</code> method.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: José L. Risco-Martín</p>
<p class="date">Created: 2024-05-31 vie 12:09</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
