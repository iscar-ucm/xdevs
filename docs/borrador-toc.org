1. *Introduction to xDEVS*
   - Overview of xDEVS
   - Key Features
   - Installation and Setup

2. *The DEVS Formalism*
   - Basic Concepts
   - Model Structure
   - Time Advance Functions

3. *Getting Started with xDEVS*
   - First Model: Ping Pong
   - Output function
   - Internal Transition Function
   - External transition function
   - Complete model implementation
   - Running the model

4. *Building Models in xDEVS*
   - Atomic Models
   - Coupled Models
   - Model Configuration

5. *Advanced Features*
   - Real-time Simulation
   - Parallel Execution
   - Custom Extensions

6. *Integration with Other Tools*
   - Data Visualization
   - Interfacing with External Software
   - Exporting and Importing Models

7. *Case Studies and Examples*
   - Simple Queue System
   - Network Packet Routing
   - Manufacturing Process

8. *Troubleshooting and FAQs*
   - Common Errors
   - Performance Optimization
   - Community and Support

9. *Appendices*
   - Glossary of Terms
   - Bibliography and References
   - Change Log

10. *Index*

This structure will help guide the user from introductory concepts through to advanced usage and integration, providing a comprehensive resource for both new and experienced users of xDEVS.

Yo haría:

3 Getting Started (solo ping pong)
4 Building models in xDEVS
5 EFP model (GPT, EFP)
6 Advanced features (real-time, parallel, distributed)
7 Case studies?

Con respecto a los ejemplos, pongo lo que llevo en borrador:

* Examples


** Introduction

xDEVS stands for /A cross-platform (x) Discrete EVent System simulator/. This library includes a set of C, C++, C#, Go, Java, Python and Rust repositories that provide an event-driven simulation interface. This interface follows the formalism /Discrete Event System Specification (DEVS)/. The project final goal is to elaborate the fastest DEVS simulation interface with capacity to simulate models in virtual and real time, and to run simulations in sequential (single-threaded), parallel (multi-threaded) and distributed (not shared memory) architectures. 

Research in the xDEVS interface can be found in [[https://doi.org/10.1002/spe.3168][xDEVS: A toolkit for interoperable modeling and simulation of formal discrete event systems]]. Please, cite our article in case you find xDEVS useful. This way we can gain visibility:

- Risco-Martín, JL, Mittal, S, Henares, K, Cardenas, R, Arroba, P. xDEVS: A toolkit for interoperable modeling and simulation of formal discrete event systems. Softw Pract Exper. 2022; 1- 42. doi:10.1002/spe.3168

There are seven repositories associated with xDEVS, each one offering the equivalent simulation interface for each corresponding programming language.

- xDEVS/C ([[https://github.com/iscar-ucm/xdevs.c][xdevs.c]])
- xDEVS/C++ ([[https://github.com/iscar-ucm/xdevs.cpp][xdevs.cpp]])
- xDEVS/C# ([[https://github.com/iscar-ucm/xdevs.cs][xdevs.cs]])
- xDEVS/Go ([[https://github.com/iscar-ucm/xdevs.go][xdevs.go]])
- xDEVS/Java ([[https://github.com/iscar-ucm/xdevs.java][xdevs.java]]) - [[https://iscar-ucm.github.io/xdevs.java][API documentation]]
- xDEVS/Python ([[https://github.com/iscar-ucm/xdevs.py][xdevs.py]])
- xDEVS/Rust ([[https://github.com/iscar-ucm/xdevs.rs][xdevs.rs]])
- xDEVS/Rust for embedded systems ([[https://github.com/iscar-ucm/xdevs_no_std.rs][xdevs_no_std.rs]])

All the repositories are included as submodules inside this main repository.

The xDEVS user's manual can be found [[https://iscar-ucm.github.io/xdevs/][here]].


Enumerate some examples I could use to include in the xDEVS API user's manual.

Certainly! Here are some examples you could include in the xDEVS API user's manual:

1. *Basic Event Simulation*:
   - A simple example demonstrating how to set up and run a basic discrete event simulation using xDEVS.

2. *Sequential Simulation*:
   - An example showing how to run a simulation in a single-threaded (sequential) manner.

3. *Parallel Simulation*:
   - A demonstration of running a simulation using multi-threading to leverage parallel processing capabilities.

4. *Distributed Simulation*:
   - An example illustrating how to set up and run a distributed simulation across multiple machines or nodes.

5. *Real-Time Simulation*:
   - A case study on how to configure and execute a real-time simulation using xDEVS.

6. *Interoperability Example*:
   - An example showcasing the interoperability between different programming languages supported by xDEVS, such as running a simulation in Python and then in C++.

7. *Embedded Systems Simulation*:
   - A specific example for simulating discrete event systems on embedded platforms using the Rust for embedded systems repository.

8. *Modeling a Traffic Light System*:
   - A practical example of modeling and simulating a traffic light system to demonstrate the application of DEVS formalism.

9. *Queueing System Simulation*:
   - An example of simulating a queueing system, such as a bank or a customer service center, to illustrate event handling and state transitions.

10. *Custom Event Handling*:
    - A detailed example on how to define and handle custom events within the xDEVS framework.

11. *Integration with External Libraries*:
    - An example showing how to integrate xDEVS with other libraries or frameworks, such as visualization tools or data analysis libraries.

12. *Performance Benchmarking*:
    - An example that includes performance benchmarking of different simulation configurations (sequential vs. parallel vs. distributed).

These examples will help users understand the capabilities and applications of the xDEVS library across different scenarios and programming environments.

OK, let's start with the traffic light system. Write this subsection of the xDEVS API user's manual for me, explaining the problem and developing the example using the xDEVS/Python API, let me give you some information about how to implement models using xDEVS/Python API.
#+begin_src python
from __future__ import annotations
import inspect
import pickle
from abc import ABC, abstractmethod
from collections import deque, defaultdict
from typing import Generator, Generic, Iterator
from xdevs import PHASE_ACTIVE, PHASE_PASSIVE, INFINITY, T


class Port(Generic[T]):
    def __init__(self, p_type: type[T] | None = None, name: str = None, serve: bool = False):
        """
        xDEVS implementation of DEVS Port.
        :param p_type: data type of events to be sent/received via the new port instance.
        :param name: name of the new port instance. Defaults to the name of the port's class.
        :param serve: set to True if the port is going to be accessible via RPC server. Defaults to False.
        """
        self.name: str = name if name else self.__class__.__name__  # Name of the port
        self.p_type: type[T] | None = p_type  # Port type. If None, it can contain any type of event.
        self.serve: bool = serve                 # True if port is going to be accessible via RPC server
        self.parent: Component | None = None     # xDEVS Component that owns the port
        self._values: deque[T] = deque()         # Bag containing events directly written to the port
        self._bag: list[Port[T]] = list()        # Bag containing coupled ports containing events

    def __bool__(self) -> bool:
        return not self.empty()

    def __len__(self) -> int:
        return sum((len(port) for port in self._bag), len(self._values))

    def __str__(self) -> str:
        p_type = self.p_type.__name__ if self.p_type is not None else 'None'
        return f'{self.name}<{p_type}>'

    def __repr__(self) -> str:
        return str(self)

    def empty(self) -> bool:
        return not bool(self._values or self._bag)

    def clear(self):
        self._values.clear()
        self._bag.clear()

    @property
    def values(self) -> Generator[T, None, None]:
        """:return: Generator function that can iterate over all the values contained in the port."""
        for val in self._values:
            yield val
        for port in self._bag:
            for val in port.values:
                yield val

    def get(self) -> T:
        """
        :return: first value in the port.
        :raises StopIteration: if port is empty.
        """
        return next(self.values)

    def add(self, val: T):
        """
        Adds a new value to the local value bag of the port.
        :param val: event to be added.
        :raises TypeError: If event is not instance of port type.
        """
        if self.p_type is not None and not isinstance(val, self.p_type):
            raise TypeError(f'Value type is {type(val).__name__} ({self.p_type.__name__} expected)')
        self._values.append(val)

    def extend(self, vals: Iterator[T]):
        """
        Adds a set of new values to the local value bag of the port.
        :param vals: list containing all the values to be added.
        :raises TypeError: If one of the values is not instance of port type.
        """
        for val in vals:
            self.add(val)

    def add_to_bag(self, port: Port[T]):
        """
        Adds a port that contains events to the message bag.
        :param port: port to be added to the bag.
        """
        if port:
            self._bag.append(port)


class Component(ABC):
    def __init__(self, name: str = None):
        """
        Abstract Base Class for an xDEVS model.
        :param name: name of the xDEVS model. Defaults to the name of the component's class.
        """
        self.name: str = name if name else self.__class__.__name__
        self.parent: Coupled | None = None # Parent component of this component
        self.input: dict[str, Port] = dict()  # Dictionary containing all the component's input ports by name
        self.output: dict[str, Port] = dict() # Dictionary containing all the component's output ports by name
        # TODO make these lists private
        self.in_ports: list[Port] = list()   # List containing all the component's input ports (serialized for performance)
        self.out_ports: list[Port] = list()  # List containing all the component's output ports (serialized for performance)

    def __str__(self) -> str:
        in_str = " ".join([p.name for p in self.in_ports])
        out_str = " ".join([p.name for p in self.out_ports])
        return f'{self.name}: InPorts[{in_str}] OutPorts[{out_str}]'

    def __repr__(self):
        return self.name

    @abstractmethod
    def initialize(self):
        """This method is executed before starting a simulation."""
        pass

    @abstractmethod
    def exit(self):
        """This method is executed after finishing a simulation."""
        pass

    def in_empty(self) -> bool:
        """:return: True if model has not any message in all its input ports."""
        return not any(self.in_ports)

    def out_empty(self) -> bool:
        """:return: True if model has not any message in all its output ports."""
        return not any(self.out_ports)

    @property
    def used_in_ports(self) -> Generator[Port, None, None]:
        return (port for port in self.in_ports if port)

    @property
    def used_out_ports(self) -> Generator[Port, None, None]:
        return (port for port in self.out_ports if port)

    def add_in_port(self, port: Port):
        """
        Adds an input port to the xDEVS model.
        :param port: port to be added to the model.
        :panics NameError: if port name already exists.
        """
        if port.name in self.input:
            raise NameError("Input port name already exists")
        port.parent = self
        self.input[port.name] = port
        self.in_ports.append(port)

    def add_out_port(self, port: Port):
        """
        Adds an output port to the xDEVS model
        :param port: port to be added to the model.
        :panics NameError: if port name already exists.
        """
        if port.name in self.output:
            raise ValueError("Output port name already exists")
        port.parent = self
        self.output[port.name] = port
        self.out_ports.append(port)

    def get_in_port(self, name) -> Port | None:
        """:return: Input port with the given name. If port is not found, returns None."""
        return self.input.get(name)

    def get_out_port(self, name) -> Port | None:
        """:return: Output port with the given name. If port is not found, returns None."""
        return self.output.get(name)


class Coupling(Generic[T]):
    def __init__(self, port_from: Port[T], port_to: Port[T], host=None):
        """
        xDEVS implementation of DEVS couplings.
        :param port_from: DEVS transmitter port.
        :param port_to: DEVS receiver port.
        :param host: TODO documentation for this
        :raises ValueError: port types are incompatible.
        """
        # Check that couplings are valid
        if port_from.p_type is not None and port_to.p_type is not None and port_to in inspect.getmro(port_from.p_type):
            raise ValueError("Ports don't share the same port type")

        self.port_from: Port = port_from
        self.port_to: Port = port_to
        self.host = host  # TODO identify host's variable type

    def __str__(self) -> str:
        return f"({self.port_from} -> {self.port_to})"

    def __repr__(self) -> str:
        return str(self)

    def propagate(self):
        """Copies messages from the transmitter port to the receiver port"""
        if self.host:
            if self.port_from:
                values = list(map(lambda x: pickle.dumps(x, protocol=0).decode(), self.port_from.values))
                self.host.inject(self.port_to, values)
        else:
            self.port_to.add_to_bag(self.port_from)


class Atomic(Component, ABC):
    def __init__(self, name: str = None):
        """
        xDEVS implementation of DEVS Atomic Model.
        :param name: name of the atomic model. If no name is provided, it will take the class's name by default.
        """
        super().__init__(name)

        self.phase: str = PHASE_PASSIVE
        self.sigma: float = INFINITY

    def ta(self) -> float:
        """:return: remaining time for the atomic model's internal transition."""
        return self.sigma

    def __str__(self) -> str:
        return f'{self.name}({self.phase}, {self.sigma})'

    @abstractmethod
    def deltint(self):
        """Describes the internal transitions of the atomic model."""
        pass

    @abstractmethod
    def deltext(self, e: float):
        """
        Describes the external transitions of the atomic model.
        :param e: elapsed time between last transition and the external transition.
        """
        pass

    @abstractmethod
    def lambdaf(self):
        """Describes the output function of the atomic model."""
        pass

    def deltcon(self):
        """Confluent transitions of the atomic model. By default, internal transition is triggered first."""
        self.deltint()
        self.deltext(0)

    def hold_in(self, phase: str, sigma: float):
        """
        Change atomic model's phase and next timeout.
        :param phase: atomic model's new phase.
        :param sigma: time remaining to the next timeout.
        """
        self.phase = phase
        self.sigma = sigma

    def activate(self, phase: str = PHASE_ACTIVE):
        """
        Sets next timeout to 0.
        :param phase: New phase. Defaults to "PHASE_ACTIVE".
        """
        self.phase = phase
        self.sigma = 0

    def passivate(self, phase: str = PHASE_PASSIVE):
        """
        Sets next timeout to infinity.
        :param phase: New phase. Defaults to "PHASE_PASSIVE".
        """
        self.phase = phase
        self.sigma = INFINITY

    def continuef(self, e: float):
        """
        Reduces the next timeout by e time units.
        :param e: elapsed time to be subtracted from sigma.
        """
        self.sigma -= e


class Coupled(Component, ABC):
    def __init__(self, name: str = None):
        """
        xDEVS implementation of DEVS Coupled Model.
        :param name: name of the coupled model. If no name is provided, it will take the class's name by default.
        """
        super().__init__(name)
        self.components: list[Component] = list()
        self.ic: dict[Port, dict[Port, Coupling]] = dict()
        self.eic: dict[Port, dict[Port, Coupling]] = dict()
        self.eoc: dict[Port, dict[Port, Coupling]] = dict()
        # TODO serialized versions of ic, eic and eoc for performance

    def initialize(self):
        pass

    def exit(self):
        pass

    def add_coupling(self, p_from: Port, p_to: Port, host=None):
        """
        Adds coupling between two submodules of the coupled model.
        :param p_from: DEVS transmitter port.
        :param p_to: DEVS receiver port.
        :param host: TODO documentation
        :raises ValueError: if coupling is not well defined.
        """
        if p_from.parent == self and p_to.parent in self.components:
            coupling_set = self.eic
        elif p_from.parent in self.components and p_to.parent == self:
            coupling_set = self.eoc
        elif p_from.parent in self.components and p_to.parent in self.components:
            coupling_set = self.ic
        else:
            raise ValueError("Components that compose the coupling are not submodules of coupled model")

        if p_from not in coupling_set:
            coupling_set[p_from] = dict()
        coupling_set[p_from][p_to] = Coupling(p_from, p_to, host)

    def remove_coupling(self, coupling: Coupling):
        """
        Removes coupling between two submodules of the coupled model.
        :param coupling: Couplings to be removed.
        :raises ValueError: if coupling is not found.
        """
        port_from = coupling.port_from
        port_to = coupling.port_to
        for coupling_set in (self.eic, self.eoc, self.ic):
            if coupling_set.get(port_from, dict()).pop(port_to, None) == coupling:
                if not coupling_set[port_from]:
                    coupling_set.pop(port_from)
                return
        raise ValueError("Coupling was not found in model definition")

    def add_component(self, component: Component):
        """
        Adds component to coupled model.
        :param component: component to be added to the Coupled model.
        """
        component.parent = self
        self.components.append(component)

    def flatten(self) -> tuple[list[Atomic], list[Coupling]]:
        """
        Flattens coupled model (i.e., parent coupled model inherits the connection of the model).
        :return: Components and couplings to be transferred to parent
        """
        new_comps_up: list[Atomic] = list()  # list with children components to be inherited by parent
        new_coups_up: list[Coupling] = list()  # list with couplings to be inherited by parent

        old_comps: list[Coupled] = list()  # list with children coupled models to be deleted

        for comp in self.components:
            if isinstance(comp, Coupled):  # Propagate flattening to children coupled models
                new_comps_down, new_coups_down = comp.flatten()
                old_comps.append(comp)
                for new_comp in new_comps_down:
                    self.add_component(new_comp)
                for coup in new_coups_down:
                    self.add_coupling(coup.port_from, coup.port_to, coup.host)
            elif isinstance(comp, Atomic):
                new_comps_up.append(comp)

        for comp in old_comps:
            self._remove_couplings_of_child(comp)
            self.components.remove(comp)

        if self.parent is not None:  # If module is not root, trigger the flatten process
            left_bridge_eic = self._create_left_bridge(self.parent.eic)
            new_coups_up.extend(self._complete_left_bridge(left_bridge_eic))

            left_bridge_ic = self._create_left_bridge(self.parent.ic)
            right_bridge_ic = self._create_right_bridge(self.parent.ic)
            new_coups_up.extend(self._complete_left_bridge(left_bridge_ic))
            new_coups_up.extend(self._complete_right_bridge(right_bridge_ic))

            right_bridge_eoc = self._create_right_bridge(self.parent.eoc)
            new_coups_up.extend(self._complete_right_bridge(right_bridge_eoc))

            new_coups_up.extend((c for cl in self.ic.values() for c in cl.values()))

        return new_comps_up, new_coups_up

    def _remove_couplings_of_child(self, child: Coupled):
        for in_port in child.in_ports:
            self._remove_couplings(in_port, self.eic)
            self._remove_couplings(in_port, self.ic)
        for out_port in child.out_ports:
            self._remove_couplings(out_port, self.ic)
            self._remove_couplings(out_port, self.eoc)

    @staticmethod
    def _remove_couplings(port: Port, couplings: dict[Port, dict[Port, Coupling]]):
        # Remove port from couplings list
        couplings.pop(port, None)
        # For remaining ports, remove couplings which source is the port to be removed
        for coups in couplings.values():
            coups.pop(port, None)
        return

    def _create_left_bridge(self, pc) -> dict[Port, list[Port]]:
        bridge = defaultdict(list)
        for in_port in self.in_ports:
            for port_from in pc:
                if in_port in pc[port_from]:
                    bridge[in_port].append(port_from)

        return bridge

    def _create_right_bridge(self, pc) -> dict[Port, list[Port]]:
        bridge = defaultdict(list)
        for out_port in self.out_ports:
            for port_from in pc:
                if port_from == out_port:
                    for port_to in pc[port_from]:
                        bridge[out_port].append(port_to)
        return bridge

    def _complete_left_bridge(self, bridge: dict[Port, list[Port]]) -> list[Coupling]:
        couplings = list()
        for coup_list in self.eic.values():
            for coup in coup_list.values():
                ports = bridge[coup.port_from]
                for port in ports:
                    couplings.append(Coupling(port, coup.port_to))
        return couplings

    def _complete_right_bridge(self, bridge: dict[Port, list[Port]]) -> list[Coupling]:
        couplings = list()
        for coup_list in self.eoc.values():
            for coup in coup_list.values():
                ports = bridge[coup.port_to]
                for port in ports:
                    couplings.append(Coupling(coup.port_from, port))
        return couplings



from __future__ import annotations

import _thread
import itertools
import pickle
import logging

from abc import ABC, abstractmethod
from collections import defaultdict
from typing import Generator, Optional
from xmlrpc.server import SimpleXMLRPCServer

from xdevs import INFINITY, T
from xdevs.models import Atomic, Coupled, Component, Port
from xdevs.abc import Transducer


class SimulationClock:
    def __init__(self, time: float = 0):
        self.time: float = time


class AbstractSimulator(ABC):
    def __init__(self, model: Component, clock: SimulationClock,
                 event_transducers_mapping: Optional[dict[Port, list[Transducer]]] = None):
        self.model: Component = model
        self.clock: SimulationClock = clock
        self.time_last: float = 0
        self.time_next: float = 0

        self.event_transducers: Optional[dict[Port, list[Transducer]]] = None
        if event_transducers_mapping:
            port_transducers: dict[Port, list[Transducer]] = dict()
            for port in itertools.chain(self.model.in_ports, self.model.out_ports):
                transducers = event_transducers_mapping.get(port, None)
                if transducers:
                    port_transducers[port] = transducers
            if port_transducers:
                self.event_transducers = port_transducers

    @property
    def imminent(self) -> bool:
        return self.clock.time == self.time_next or not self.model.in_empty()

    def trigger_event_transducers(self):
        if self.event_transducers is not None:
            for port, transducers in self.event_transducers.items():
                if port:  # Only for ports with messages
                    for trans in transducers:
                        trans.add_imminent_port(port)

    @abstractmethod
    def initialize(self):
        pass

    @abstractmethod
    def exit(self):
        pass

    @abstractmethod
    def ta(self) -> float:
        pass

    @abstractmethod
    def lambdaf(self):
        pass

    @abstractmethod
    def deltfcn(self) -> AbstractSimulator | None:
        pass

    @abstractmethod
    def clear(self):
        pass


class Simulator(AbstractSimulator):
    model: Atomic

    def __init__(self, model: Atomic, clock: SimulationClock,
                 event_transducers_mapping: Optional[dict[Port, list[Transducer]]] = None,
                 state_transducers_mapping: Optional[dict[Atomic, list[Transducer]]] = None):
        super().__init__(model, clock, event_transducers_mapping)
        self.state_transducers: list[Transducer] | None = None
        if state_transducers_mapping:
            self.state_transducers = state_transducers_mapping.get(self.model, None)

    @property
    def ta(self) -> float:
        return self.model.ta()

    def initialize(self):
        self.model.initialize()
        self.time_last = self.clock.time
        self.time_next = self.time_last + self.model.ta()

    def exit(self):
        self.model.exit()

    def deltfcn(self) -> Simulator | None:  # TODO
        if not self.model.in_empty():
            if self.clock.time == self.time_next:
                self.model.deltcon()
            else:
                e = self.clock.time - self.time_last
                self.model.deltext(e)
        elif self.clock.time == self.time_next:
            self.model.deltint()
        else:
            return

        if self.state_transducers is not None:
            for trans in self.state_transducers:
                trans.add_imminent_model(self.model)

        self.trigger_event_transducers()

        self.time_last = self.clock.time
        self.time_next = self.time_last + self.model.ta()
        return self

    def lambdaf(self):
        if self.clock.time == self.time_next:
            self.model.lambdaf()

    def clear(self):
        for port in itertools.chain(self.model.in_ports, self.model.out_ports):
            port.clear()


class Coordinator(AbstractSimulator):
    model: Coupled

    def __init__(self, model: Coupled, clock: Optional[SimulationClock] = None, flatten: bool = False,
                 event_transducers_mapping: Optional[dict[Port, list[Transducer]]] = None,
                 state_transducers_mapping: Optional[dict[Atomic, list[Transducer]]] = None):
        super().__init__(model, clock or SimulationClock(), event_transducers_mapping)

        self.coordinators: list[Coordinator] = list()
        self.simulators: list[Simulator] = list()
        self._transducers: Optional[list[Transducer]] = [] if self.root_coordinator else None

        if flatten:
            self.model.flatten()
            # TODO we must fix transducers here!
        self.ports_to_serve = dict()

        self.__event_transducers_mapping: dict[Port, list[Transducer]] | None = None
        self.__state_transducers_mapping: dict[Atomic, list[Transducer]] | None = None
        if not self.root_coordinator:
            # Only non-root coordinators will load the transducers mapping in the constructor.
            # Root coordinator ignores them, as it is in charge of building them in _build_hierarchy
            self.event_transducers_mapping = event_transducers_mapping
            self.state_transducers_mapping = state_transducers_mapping

    @property
    def root_coordinator(self) -> bool:
        return self.model.parent is None

    @property
    def event_transducers_mapping(self) -> dict[Port, list[Transducer]] | None:
        return self.__event_transducers_mapping

    @property
    def state_transducers_mapping(self) -> dict[Atomic, list[Transducer]] | None:
        return self.__state_transducers_mapping

    @event_transducers_mapping.setter
    def event_transducers_mapping(self, event_transducers_mapping: dict[Port, list[Transducer]] | None):
        if event_transducers_mapping:
            self.__event_transducers_mapping = event_transducers_mapping

    @state_transducers_mapping.setter
    def state_transducers_mapping(self, state_transducers_mapping: dict[Atomic, list[Transducer]] | None):
        if state_transducers_mapping:
            self.__state_transducers_mapping = state_transducers_mapping

    @property
    def processors(self) -> Generator[AbstractSimulator, None, None]:
        for coord in self.coordinators:
            yield coord
        for sim in self.simulators:
            yield sim

    @property
    def imminent_processors(self) -> Generator[AbstractSimulator, None, None]:
        return (proc for proc in self.processors if proc.imminent)

    def initialize(self):
        self._build_hierarchy()

        for proc in self.processors:
            proc.initialize()

        self.time_last = self.clock.time
        self.time_next = self.time_last + self.ta()

        if self._transducers is not None:
            for transducer in self._transducers:
                transducer.initialize()

    def _build_hierarchy(self):
        if self.root_coordinator and self._transducers:
            # The root coordinator is in charge of
            ports_to_transducers: dict[Port, list[Transducer]] = defaultdict(list)
            models_to_transducers: dict[Atomic, list[Transducer]] = defaultdict(list)
            for transducer in self._transducers:
                for model in transducer.target_components:
                    models_to_transducers[model].append(transducer)
                for port in transducer.target_ports:
                    ports_to_transducers[port].append(transducer)
            self.event_transducers_mapping = ports_to_transducers
            self.state_transducers_mapping = models_to_transducers

        for comp in self.model.components:
            if isinstance(comp, Coupled):
                coord = Coordinator(comp, self.clock, event_transducers_mapping=self.event_transducers_mapping,
                                    state_transducers_mapping=self.state_transducers_mapping)
                self.coordinators.append(coord)
                self.ports_to_serve.update(coord.ports_to_serve)
            elif isinstance(comp, Atomic):
                sim = Simulator(comp, self.clock, event_transducers_mapping=self.event_transducers_mapping,
                                state_transducers_mapping=self.state_transducers_mapping)
                self.simulators.append(sim)
                for pts in sim.model.in_ports:
                    if pts.serve:
                        port_name = "%s.%s" % (pts.parent.name, pts.name)
                        self.ports_to_serve[port_name] = pts

    def add_transducer(self, transducer: Transducer):
        if self._transducers is None:
            raise RuntimeError('Only the root coordinator can contain transducers')
        self._transducers.append(transducer)

    def serve(self, host: str = "localhost", port: int = 8000):
        server = SimpleXMLRPCServer((host, port))
        server.register_function(self.inject)
        _thread.start_new_thread(server.serve_forever, ())

    def exit(self):
        for processor in self.processors:
            processor.exit()

        if self._transducers is not None:
            for transducer in self._transducers:
                transducer.exit()

    def ta(self):
        return min((proc.time_next for proc in self.processors), default=INFINITY) - self.clock.time

    def lambdaf(self):
        for proc in self.processors:
            if self.clock.time == proc.time_next:
                proc.lambdaf()
                self.propagate_output(proc.model)

    def propagate_output(self, comp: Component):
        for port in comp.used_out_ports:
            for coup in itertools.chain(self.model.ic.get(port, dict()).values(),
                                        self.model.eoc.get(port, dict()).values()):
                coup.propagate()

    def deltfcn(self):
        self.propagate_input()

        for proc in self.imminent_processors:
            proc.deltfcn()

        self.trigger_event_transducers()

        self.time_last = self.clock.time
        self.time_next = self.time_last + self.ta()

    def propagate_input(self):
        for port in self.model.used_in_ports:
            for coup in self.model.eic.get(port, dict()).values():
                coup.propagate()

    def clear(self):
        for port in itertools.chain(self.processors, self.model.in_ports, self.model.out_ports):
            port.clear()

    def inject(self, port: str | Port[T], values: T | list[T], e: float = 0) -> bool:
        # TODO enable any iterable as values (careful with str)
        time = self.time_last + e

        if type(values) is not list:
            values = [values]

        if isinstance(port, str):
            values = list(map(lambda x: pickle.loads(x.encode()), values))
            if port in self.ports_to_serve:
                port = self.ports_to_serve[port]
            else:
                # logger.error("Port '%s' not found" % port)
                return True  # TODO is this OK?

        if time <= self.time_next or time != time:
            port.extend(values)
            self.clock.time = time
            self.deltfcn()
            self.clear()
            self.clock.time = self.time_next
            return True
        else:
            # logger.error("Time %d - Input rejected: elapsed time %d is not in bounds" % (self.time_last, e))
            return False

    def simulate(self, num_iters: int = 10000):
        self.clock.time = self.time_next
        cont = 0
        while cont < num_iters and self.clock.time < INFINITY:
            self.lambdaf()
            self.deltfcn()
            self._execute_transducers()
            self.clear()
            self.clock.time = self.time_next
            cont += 1

    def simulate_time(self, time_interv: float = INFINITY):
        self.clock.time = self.time_next
        tf = self.clock.time + time_interv
        while self.clock.time < tf:
            self.lambdaf()
            self.deltfcn()
            self._execute_transducers()
            self.clear()
            self.clock.time = self.time_next

    def _execute_transducers(self):
        for transducer in self._transducers:
            transducer.trigger(self.clock.time)


import logging
import time
from xdevs import PHASE_ACTIVE, PHASE_PASSIVE, get_logger
from xdevs.models import Atomic, Coupled, Port

logger = get_logger(__name__, logging.DEBUG)

PHASE_DONE = "done"


class Job:
    def __init__(self, name: str):
        """
        Job event class. It represents a job sent by the generator and processed by the processor.
        :param name: job name
        """
        self.name: str = str(name)
        self.time: float = 0
    def __str__(self):
        return self.name


class Generator(Atomic):
    def __init__(self, name: str, gen_t: float):
        """
        Generator model. It generates jobs at a given period.
        :param name: model name
        :param gen_t: period between job generations
        """
        super().__init__(name)

        if gen_t < 1:
            raise ValueError('gen_t must be greater than 0')

        self.i_stop: Port[bool] = Port(bool, "i_stop")
        self.o_job: Port[Job] = Port(Job, "o_out")

        self.add_in_port(self.i_stop)
        self.add_out_port(self.o_job)

        self.gen_t: float = gen_t
        self.job_counter: int = 1

    def initialize(self):
        self.hold_in(PHASE_ACTIVE, self.gen_t)

    def exit(self):
        pass

    def deltint(self):
        self.job_counter += 1
        self.hold_in(PHASE_ACTIVE, self.gen_t)

    def deltext(self, e):
        self.continuef(e)
        if self.i_stop.get():
            self.passivate()
        elif self.sigma == float('inf'):
            self.hold_in(PHASE_ACTIVE, self.gen_t)

    def lambdaf(self):
        self.o_job.add(Job(str(self.job_counter)))


class Processor(Atomic):
    def __init__(self, name: str, proc_t: float):
        """
        Processor model. It processes jobs with a given processing time.
        :param name: model name
        :param proc_t: processing time
        """
        super().__init__(name)

        if proc_t < 1:
            raise ValueError('proc_t must be greater than 0')

        self.i_in: Port[Job] = Port(Job, "i_in")
        self.o_out: Port[Job] = Port(Job, "o_out")

        self.add_in_port(self.i_in)
        self.add_out_port(self.o_out)

        self.current_job: Job | None = None
        self.proc_t: float = proc_t

    def initialize(self):
        self.passivate()

    def exit(self):
        pass

    def deltint(self):
        self.passivate()

    def deltext(self, e):
        if self.phase == PHASE_PASSIVE:
            self.current_job = self.i_in.get()
            self.hold_in(PHASE_ACTIVE, self.proc_t)
        else:
            self.continuef(e)

    def lambdaf(self):
        self.o_out.add(self.current_job)


class Transducer(Atomic):
    def __init__(self, name: str, obs_t: float):
        super().__init__(name)

        if obs_t < 0:
            raise ValueError('obs_t must be greater or equal than 0')

        self.i_arrived: Port[Job] = Port(Job, "i_arrived")
        self.i_solved: Port[Job] = Port(Job, "i_solved")
        self.o_out: Port[bool] = Port(bool, "o_out")

        self.add_in_port(self.i_arrived)
        self.add_in_port(self.i_solved)
        self.add_out_port(self.o_out)

        self.jobs_arrived: list[Job] = []
        self.jobs_solved: list[Job] = []

        self.total_ta: float = 0
        self.clock: float = 0
        self.obs_t: float = obs_t

    def initialize(self):
        self.hold_in(PHASE_ACTIVE, self.obs_t)

    def exit(self):
        pass

    def deltint(self):
        self.clock += self.sigma

        if self.phase == PHASE_ACTIVE:
            avg_ta = 0
            throughput = 0
            if self.jobs_solved:
                avg_ta = self.total_ta / len(self.jobs_solved)
                throughput = len(self.jobs_solved) / self.clock if self.clock > 0 else 0

            logger.info(f'End time: {self.clock}')
            logger.info(f'Jobs arrived: {len(self.jobs_arrived)}')
            logger.info(f'Jobs solved: {len(self.jobs_solved)}')
            logger.info(f'Average TA: {avg_ta}')
            logger.info(f'Throughput: {throughput}')

            self.hold_in(PHASE_DONE, 0)
        else:
            self.passivate()

    def deltext(self, e):
        self.clock += e

        if self.phase == PHASE_ACTIVE:
            if self.i_arrived:
                job = self.i_arrived.get()
                logger.info(f'Starting job {job.name} @ t = {self.clock} @ t = {time.time_ns()}')
                job.time = self.clock
                self.jobs_arrived.append(job)

            if self.i_solved:
                job = self.i_solved.get()
                logger.info(f'Job {job.name} finished @ t = {self.clock} @ t = {time.time()}')
                self.total_ta += self.clock - job.time
                self.jobs_solved.append(job)

        self.continuef(e)

    def lambdaf(self):
        if self.phase == PHASE_DONE:
            self.o_out.add(True)

class Ef(Coupled):
    def __init__(self, name: str, gen_t: float, obs_t: float):
        super().__init__(name)

        gen = Generator('generator', gen_t)
        trans = Transducer('transducer', obs_t)

        self.add_component(gen)
        self.add_component(trans)

        self.p_in_ef = Port(Job, name='p_in_ef')
        self.p_out_ef = Port(Job, name='p_out_ef')

        self.add_in_port(self.p_in_ef)
        self.add_out_port(self.p_out_ef)

        self.add_coupling(gen.o_job, trans.i_arrived)
        self.add_coupling(gen.o_job, self.p_out_ef)
        self.add_coupling(trans.o_out, gen.i_stop)
        self.add_coupling(self.p_in_ef, trans.i_solved)


class Efp(Coupled):
    def __init__(self, name: str, gen_t: float, proc_t: float, obs_t: float):
        super().__init__(name)

        ef = Ef('ef', gen_t, obs_t)
        proc = Processor('processor', proc_t)

        self.add_component(ef)
        self.add_component(proc)

        self.add_coupling(ef.p_out_ef, proc.i_in)
        self.add_coupling(proc.o_out, ef.p_in_ef)
class Gpt(Coupled):
    def __init__(self, name: str, gen_t: float, proc_t: float, obs_t: float):
        super().__init__(name)

        gen = Generator('generator', gen_t)
        proc = Processor('processor', proc_t)
        trans = Transducer('transducer', obs_t)

        self.add_component(gen)
        self.add_component(proc)
        self.add_component(trans)

        self.add_coupling(gen.o_job, proc.i_in)
        self.add_coupling(gen.o_job, trans.i_arrived)
        self.add_coupling(proc.o_out, trans.i_solved)
        self.add_coupling(trans.o_out, gen.i_stop)

class GptIHOH(Coupled):

    # Adaptation of the GPT DEVS model for injecting events via a new input port and for ejection of events via a new
    # output port.

    def __init__(self, name: str, gen_t: float, proc_t: float, obs_t: float):
        super().__init__(name)

        gen = Generator('generator', gen_t)
        proc = Processor('processor', proc_t)
        trans = Transducer('transducer', obs_t)

        # New input handler port
        self.ih_in = Port(Job, name='ih_in')
        self.add_in_port(self.ih_in)

        # New output handler port
        self.oh_out = Port(Job, name='oh_out')
        self.add_out_port(self.oh_out)

        self.add_component(gen)
        self.add_component(proc)
        self.add_component(trans)

        # New coupling for the input handler
        self.add_coupling(self.ih_in, proc.i_in)

        # New coupling for the output handler
        self.add_coupling(proc.o_out, self.oh_out)

        self.add_coupling(gen.o_job, proc.i_in)
        self.add_coupling(gen.o_job, trans.i_arrived)
        self.add_coupling(proc.o_out, trans.i_solved)
        self.add_coupling(trans.o_out, gen.i_stop)

from xdevs.sim import Coordinator
from xdevs.examples.gpt.models import Gpt

if __name__ == '__main__':

    gpt = Gpt("gpt", 3, 5, 100)
    coord = Coordinator(gpt)
    coord.initialize()
    coord.simulate()


#+end_src


*** Traffic Light System Example

**** Problem Description

In this example, we will model a simple traffic light system using the xDEVS/Python API. The traffic light will cycle through three states: Green, Yellow, and Red. Each state will have a specific duration, and the system will transition between these states in a loop.

**** Model Implementation

We will create an atomic model for the traffic light, which will handle the state transitions and timing. The traffic light will have one output port to indicate the current state.

**** Traffic Light Model

#+begin_src python
from xdevs.models import Atomic, Port
from xdevs.sim import Coordinator, SimulationClock

# Define the states
STATE_GREEN = "Green"
STATE_YELLOW = "Yellow"
STATE_RED = "Red"

class TrafficLight(Atomic):
    def __init__(self, name: str, green_time: float, yellow_time: float, red_time: float):
        super().__init__(name)
        self.green_time = green_time
        self.yellow_time = yellow_time
        self.red_time = red_time

        self.state = STATE_GREEN
        self.sigma = green_time

        self.output_port = Port(str, "state")
        self.add_out_port(self.output_port)

    def initialize(self):
        self.hold_in(STATE_GREEN, self.green_time)

    def deltint(self):
        if self.state == STATE_GREEN:
            self.state = STATE_YELLOW
            self.hold_in(STATE_YELLOW, self.yellow_time)
        elif self.state == STATE_YELLOW:
            self.state = STATE_RED
            self.hold_in(STATE_RED, self.red_time)
        elif self.state == STATE_RED:
            self.state = STATE_GREEN
            self.hold_in(STATE_GREEN, self.green_time)

    def deltext(self, e):
        pass

    def lambdaf(self):
        self.output_port.add(self.state)

    def exit(self):
        pass

# Simulation setup
if __name__ == "__main__":
    green_time = 10.0
    yellow_time = 2.0
    red_time = 8.0

    traffic_light = TrafficLight("TrafficLight", green_time, yellow_time, red_time)
    clock = SimulationClock()
    coordinator = Coordinator(traffic_light, clock)

    coordinator.initialize()
    coordinator.simulate(50)  # Simulate for 50 iterations
#+end_src

**** Explanation

1. *TrafficLight Class*: This class extends the =Atomic= class from the xDEVS library. It defines the traffic light states and their durations.
   - =initialize()=: Sets the initial state to Green and the initial time advance (=sigma=) to the green light duration.
   - =deltint()=: Handles internal transitions between states.
   - =lambdaf()=: Outputs the current state to the =output_port=.
   - =exit()=: Placeholder for any cleanup operations.

2. *Simulation Setup*: The main block sets up the traffic light model with specified durations for each state. It then creates a =Coordinator= to manage the simulation and runs the simulation for 50 iterations.

This example demonstrates how to model a simple traffic light system using the xDEVS/Python API, showcasing the basic principles of discrete event simulation with DEVS formalism.
